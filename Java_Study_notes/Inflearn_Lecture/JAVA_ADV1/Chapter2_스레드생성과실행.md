# 📚 Chapter 2: 스레드 생성과 실행

> 📌 공부 날짜: 2025/04/11
> - `JAVA `- 고급1편
> - `Reference`: 인프런 - 김영한의 실전 자바

---

### 🔍 자바 스택 영역
- 스택 영역은 더 정확히는 각 스레드 별로 하나의 실행 스택이 생성된다.
- 따라서 스레드 수 만큼 스택이 생성된다.

---

## ✅ 스레드 생성
- 스레드를 만들 때 Thread 클래스를 상속받는 방법과 Runnable 인터페이스를 구현하는 방법이 있다.

### 📚 스레드 생성 - Thread 상속
- 자바는 많은 것을 객체로 다룬다. 스레드도 객체로 다룬다.
- 스레드가 필요하면, 스레드 객체를 생성해서 사용하면 된다.
```java
public class HelloThread extends Thread {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + " : run()");
    }
} 
```
- Thread 클래스를 상속하고, 스레드가 실행할 코드 run()을 재정의한다.
- Thread.currentThread()를 호출하면 해당 코드를 실행하는 스레드 객체를 조회할 수 있다.
- .getName()은 실행 중인 스레드의 이름을 조회한다.
- 앞서 만든 HelloThread 객체를 생성하고 start() 메서드를 호출한다.
- start() 메서드는 스레드를 실행하는 아주 특별한 메서드이다.
- start()를 호출하면 HelloThread의 run() 메서드는 실행한다.

> 🚨 주의: run() 메서드가 아니라 반드시 start() 메서드를 호출해야 한다. 그래야 별도의 스레드에서 run() 코드가 실행된다.
- 스레드에 이름을 주지 않으면 Thread-(), Thread-1과 같은 임의의 이름을 부여한다.
- 메서드를 실행하면 스택 위에 스택 프레임이 쌓인다.
- 스레드 간 실행 순서는 보장하지 않는다.
    - 스레드는 동시에 실행되기 때문에 스레드 간에 실행 순서는 얼마든지 달라질 수 있다.

- **🔍 스레드는 순서와 실행 시간을 모두 보장하지 않는다. 이것이 `멀티 스레드`이다.**

> `run()` vs `start()`
> - 스레드의 start() 메서드는 스레드에 스택 공간을 할당하면서 스레드를 시작하는 아주 특별한 메서드이다. 그리고 해당 스레드에서 run() 메서드를 실행한다.
> - 직접 run() 메서드를 호출하면 main() 스레드가 run() 메서드를 실행했기 때문에 main 스레드가 사용하는 스택 위에 run() 스택 프레임이 올라간다.

---

### 📚 데몬 스레드
- 스레드는 사용자(user) 스레드와 데몬(daemon) 스레드 2가지 종류로 구분할 수 있다.

    1. 사용자 스레드
    - 프로그램이 주요 작업을 수행한다.
    - 작업이 완료될 때까지 실행된다.
    - 모든 user 스레드가 종료되면 JVM도 종료된다.

    2. 데몬 스레드
    - 백그라운드에서 보조적인 작업을 수행한다.
    - 모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료된다.

- **JVM은 데몬 스레드의 실행 완료를 기다리지 않고 종료되낟. 데몬 스레드가 아닌 모든 스레드가 종료되면, 자바 프로그램도 종료된다.**

> 🔍 용어: **데몬**
> - 컴퓨터 과학에서의 의미는 사용자에게 직접적으로 보이지 않으면서 시스템의 백그라운드에서 작업을 수행하는 것을 데몬 스레드. 데몬 프로세스라 한다.
> - 예를 들어서, 사용하지 않는 파일이나 메모리를 정리하는 작업들이 있다.
    >   - ex) helloThread.setDaemon(true); // 데몬 스레드 여부
>   - helloThread.start();
> - setDaemon(true): 데몬 스레드로 설정한다.
> - 데몬 스레드 여부는 start() 실행 전에 결정해야 한다. 이후에는 변경되지 않는다.
> - 기본 값은 `false`이다. (user 스레드가 기본)

- run() 메서드 안에 Thread.sleep()를 호출할 때 체크 예외인 `InterruptedException`을 밖으로 던질 수 없고 반드시 잡아야 한다.
    - run() 메서드는 체크 예외를 밖으로 던질 수 없다.

---

### 📚 스레드 생성 - Runnable
```java
public class HelloRunnable implements Runnable {
    @Override
    public void run() {}
}

// 스레드 실행 방법
HelloRunnable runnable = new HelloRunnable();
Thread thread = new Thread(runnable);
thread.start();
```
- 실행 결과는 기존과 같다. 차이가 있다면, 스레드와 해당 스레드가 실행할 작업이 분리되어 있다는 점이다.
- 스레드 객체를 생성할 때, 실행할 작업을 생성자로 전달하면 된다.

> 🔍 Thread 상속 vs Runnable 구현
> - 스레드 사용할 때는 `Thread`를 상속받는 방법보다 `Runnable` 인터페이스를 구현하는 방식을 사용한다.
1. Thread 클래스 상속 방식
- 장점
    - 간단한 구현: Thread 클래스를 상속받아 run() 메서드만 재정의하면 된다.
- 단점
    - 상속의 제한: 자바는 단일 상속만을 허용하므로 이미 다른 클래스를 상속받는 경우 상속받을 수 없다.
    - 유연성 부족: 인터페이스를 사용하는 방법에 비해 유연성이 떨어진다.

2. Runnable 인터페이스 구현 방식
    - 장점
        - 상속의 자유로움
        - 코드의 분리: 스레드와 실행할 작업을 분리하여 코드의 가독성을 높일 수 있다.
        - 여러 스레드가 동일한 Runnable 객체를 공유할 수 있어 자원 관리를 효율적으로 할 수 있다.
    - 단점
        - 코드가 약간 복잡해질 수 있다. Runnable 객체를 생성하고 이 Thread 전달하는 과정이 추가된다.

> ❗ 정리
> - Runnable 인터페이스를 구현하는 방식을 사용하자.
> - 스레드와 실행할 작업을 명확히 분리하고, 인터페이스를 사용하므로 Thread 클래스를 직접 상속하는 방식보다 더 유연하고 유지보수 하기 쉬운 코드를 만들 수 있다.

---
