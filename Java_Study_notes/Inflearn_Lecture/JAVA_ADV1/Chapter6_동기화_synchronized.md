# 📚 Chapter 6: 동기화 - synchronized

> 📌 공부 날짜: 2025/04/21
> - `JAVA `- 고급 1편
> - `Reference`: 인프런 - 김영한의 실전 자바

---

## ✅ 메모리 가시성
- 멀티스레드를 사용할 때 가장 주의해야 할 점은, 같은 자원(리소스)에 여러 스레드가 동시에 접근할 때 발생하는 동시성 문제이다.
  - 참고로 여러 스레드가 접근하는 자원을 `공유 자원`이라고 한다.
  - 대표적인 공유 자원은 인스턴스의 필드(멤버 변수)이다.
  - 멀티스레드를 사용할 때는 이런 공유 자원에 대한 접근을 적절하게 동기화(synchronized)해서 동시성 문제가 발생하지 않게 방지하는 것이 중요하다.

> 🤔 동시성 문제 예시
> - 악의적인 사용자가 2대의 PC에서 동시에 같은 계좌의 돈을 출금한다고 가정한다.
> - t1, t2 스레드가 있을 때 두 스레드는 거의 동시에 실행된다. 계좌의 돈이 출금액보다 적으면 출금이 안 되어야 하는 로직이 있다.
> - 예시로 잔고가 1,000원이고 출금액은 둘 다 800원일 때 두 스레드 중 뒤에 온 하나는 출금이 안 되어야 한다.
>   - 하지만 동시성 문제를 해결하지 않은 로직일 경우, 두 스레드는 거의 동시에 검증 로직을 접근하기 때문에 둘 다 검증 로직을 통과하게 되어 최종 결과가 -600원이 된다.
> - 이 문제를 해결하기 위해서는 먼저 들어온 스레드 하나를 검증 로직을 거치고 출금까지 하여 잔액의 결과에 변화를 준 후에 다음 스레드를 검증 로직을 수행하게 해야 이와 같은 오류를 막을 수 있다.

### 📚 임계 영역 (Critical Section)
- 여러 스레드가 동시에 접근하면 데이터 불일치나 예상치 못한 동작이 발생할 수 있는 위험하고 또 중요한 코드 부분을 뜻한다.
- 여러 스레드가 동시에 접근해서는 안 되는 공유 자원을 접근하거나 수행하는 부분을 의미한다.
  - 예) 공유 변수나 공유 객체를 수정.
- 이런 임계 영역은 한 번에 하나의 스레드만 접근할 수 있도록 안전하게 보호해야 한다.
- 여러 가지 방법이 있지만 자바는 synchronized 키워드를 통해 아주 간단하게 보호할 수 있다.

---

### 📚 synchronized 메서드
```java
public synchronized boolean withdraw(int amount) {}
```
- 모든 객체(인스턴스)는 내부에 자신만의 락(lock)을 가지고 있다.
   - 모니터 락(monitor lock)이라고도 부른다.
- 스레드가 synchronized 키워드가 있는 메서드에 진입하려면 반드시 해당 인스턴스의 락이 있어야 한다.
- t1, t2라는 두 스레드가 있고, t1이 먼저 실행된다고 가정했을 때 synchronized 메서드를 호출할 때 두 스레드가 공유하는 인스턴스의 락을 가져온다.
- 이때 뒤이어 t2 스레드도 synchronized 메서드 호출을 시도하는데, t1이 락을 가져갔으므로 t2는 가져올 락이 없어 락을 획득할 때까지 BLOCKED 상태로 대기한다.
  - t2 스레드의 상태는 RUNNABLE -> BLOCKED 상태로 변하고, 락을 획득할 때까지 무한정 대기한다.
- **참고로 BLOCKED 상태가 되면 락을 다시 획득하기 전까지는 계속 대기하고, CPU 스케줄링에 들어가지 않는다.**
- t1 스레드는 메서드 호출이 끝나면 락을 반납한다.
- t2 스레드는 락이 반납되면서 락 획득을 대기하는 t2 스레드가 자동으로 락을 획득한다.

> 🔍 참고 1: 락을 획득하는 순서는 보장되지 않는다.
> - 임계 영역에 두 스레드 말고도 수많은 스레드가 동시에 호출된다면, 1개의 스레드만 락을 획득하고 나머지는 모드 BLOCKED 상태가 된다.
> - 이때 락을 반납하면, 해당 인스턴스의 락을 기다리는 수많은 스레드 중 하나의 스레드만 락을 획득한다.
> - 이때 어떤 순서로 락을 획득하는지는 자바 표준에 정의되어 있지 않다.
>   - 따라서, 순서를 보장하지 않고, 환경에 따라 순서가 달라질 수 있다.
- 🔍 참고 2: volatile을 사용하지 않아도 synchronized 안에서 접근하는 변수의 메모리 가시성 문제는 해결된다.

---

### 📚 synchronized 코드 블록
- 가장 큰 장점이자 단점은 한 번에 하나의 스레드만 실행할 수 있다는 점이다.
- 여러 스레드가 동시에 실행하지 못하기 때문에, 전체로 보면 성능이 떨어질 수 있다.
- 따라서, synchronized를 통해 여러 스레드를 동시에 실행할 수 없는 코드 구간은 꼭 필요한 곳으로 한정해서 선정해야 한다.
- 공유 자원을 전혀 사용하지 않는 부분은 여러 스레드가 동시에 접근해도 상관이 없다.
    - 자바는 이런 문제를 해결하기 위해 synchronized를 메서드 단위가 아니라, 특정 코드 블록에 최적화해서 적용할 수 있는 기능을 제공한다.
```java
public boolean withdraw(int amount) {
   synchronized (this) {} // 이 코드 블록에서만 하나의 스레드만 접근 가능.
} 
```
- synchronized (this) {}: 안전한 임계 영역을 코드 블록으로 저장한다.
  - 이렇게 하면 꼭 필요한 코드만 안전한 임계 영억으로 만들 수 있다.
  - 여기서 괄호 () 안에 들어갈 값은 획득할 인스턴스의 참조 값이다.

> ❗핵심
> - 하나의 스레드만 실행할 수 있는 안전한 임계 영역은 가능한 최소한의 범위에 적용해야 한다는 점이다.
> - 그래야 동시에 여러 스레드가 실행할 수 있는 부분을 늘려서, 전체적인 처리 성능을 더 높일 수가 있다.

#### 🔍 이런 동기화를 사용하면 다음 문제들을 해결할 수 있다.
1. 경합 조건 (Race Condition): 두 개 이상의 스레드가 경쟁적으로 동일한 자원을 수정할 때 발생하는 문제.
2. 데이터 일관성: 여러 스레드가 동시에 읽고 쓰는 데이터의 일관성을 유지.

- **동기화는 멀티스레드 환경에서 필수적인 기능이지만, 과도하게 사용할 경우 성능 저하를 초래할 수 있으므로 꼭 필요한 곳에 적절히 사용해야 한다.**

---

### 📚 지역 변수의 공유
- ❓ 지역 변수에 동시성 문제가 발생하는지 않는지?
- 🔍 답
  - 스택 영역은 각각의 스레드가 가지는 별도의 메모리 공간이다. 이 메모리 공간은 다른 스레드와 공유하지 않는다.
  - 지역 변수는 스레드의 개별 저장 공간인 스택 영역에 생성된다.
  - 따라서 지역 변수는 절대로 다른 스레드와 공유되지 않는다.
- 이런 이유로 지역 변수는 동기화에 대한 걱정을 하지 않아도 된다.
- 지역 변수를 제외한 인스턴스의 멤버 변수(필드), 클래스 변수 등은 공유될 수 있다.

---

### 📚 final 필드
- ❓ final로 선언한 멤버 변수는 공유되는 값이다. 멀티스레드 상황에서 문제가 될 수 있을까?
- 🔍 답
  - 여러 스레드가 공유 자원에 접근하는 것 자체는 문제가 되지 않는다. 진짜 문제는 공유 자원을 사용하는 중간에 다른 스레드가 공유 자원의 값을 변경해 버리기 때문에 발생한다.
    - 결국 변경이 문제가 되는 것이다.
  - 여러 스레드가 접근 가능한 공유 자원이라도, 그 값을 아무도 변경하지 못하면 문제가 안 된다.
  - 필드에 final이 붙으면 어떤 스레드도 값을 변경할 수 없다. 따라서 멀티스레드 상황에 문제없는 안전한 공유 자원이 된다.

---

### 📚 synchronized 장점
- 아주 편리한 성능
- 자동 잠금 해제: synchronized 메서드나 블록이 완료되면 자동으로 락을 대기 중인 다른 스레드의 잠금이 해제된다.
- **synchronized는 매우 편리하지만, 제공하는 기능이 너무 단순하다는 단점이 있다.**
  - 시간이 지나면서 멀티스레드가 더 중요해지고, 점점 더 복잡한 동시성 개발 방법들이 필요해졌다.

---

### 📚 synchronized 단점
- 무한 대기: BLOCKED 상태의 스레드는 락이 풀릴 때까지 무한 대기한다.
  - 특정 시간까지만 대기하는 타임아웃이 없다❌.
  - 중간에 인터럽트 불가❌.
- 공정성: 락이 돌아왔을 때, BLOCKED 상태의 여러 스레드 중에 어떤 스레드가 락을 획득할지는 알 수 없다.
  - 최악의 경우 특정 스레드가 너무 오랜 기간 동안 락을 획득하지 못할 수도 있다.

> 🤔 결국 더 유연하고, 더 세밀한 제어가 가능한 방법들이 더 필요해졌다.
> - 이런 문제를 해결하기 위해 자바 1.5부터 java.util.concurrent라는 동시성 문제 해결을 위한 패키지가 추가되었다.
>   - 참고로 단순하고 편리하게 사용하기에는 synchronized가 좋으므로, 목적에 부합하다면 사용하면 된다.

---