# 📚 Chapter 8: 생산자 소비자 문제1

> 📌 공부 날짜: 2025/04/24
> - `JAVA `- 고급 1편
> - `Reference`: 인프런 - 김영한의 실전 자바

---

## ✅ 생산자 소비자 문제 - 소개
- 멀티스레드 프로그래밍에서 자주 등장하는 동시성 문제 중 하나로, 여러 스레드가 동시에 데이터를 생산하고 소비하는 상황을 다룬다.

### 📚 기본 개념
1. **생산자(Producer)**: 데이터를 생성하는 역할을 한다.
  - 예를 들어, 파일에서 데이터를 읽어오거나 네트워크에서 데이터를 받아오는 스레드 생산자 역할을 할 수 있다.

2. **소비자(Consumer)**: 생성된 데이터를 사용하는 역할을 한다.
  - 예를 들어, 데이터를 처리하거나 저장하는 스레드가 소비자 역할을 할 수 있다.

3. **버퍼(Buffer)**: 생산자가 생성한 데이터를 일시적으로 저장하는 공간이다.
  - 이 버퍼는 한정된 크기를 가지며, 생산자와 소비자가 이 버퍼를 통해 데이터를 주고받는다.

---

### 📚 문제 상황
1. 생산자가 너무 빠를 때
  - 버퍼가 가득 차서 더 이상 데이터를 넣을 수 없을 때까지 생산자가 데이터를 생산한다.
  - 버퍼가 가득 찬 경우 생산자는 버퍼에 빈 공간이 생길 때까지 기다려야 한다.

2. 소비자가 너무 빠를 때
  - 버퍼가 비어서 더 이상 소비할 데이터가 없을 때까지 소비자가 데이터를 처리한다.
  - 버퍼가 비어있을 때 소비자는 버퍼에 새로운 데이터가 들어올 때까지 기다려야 한다.

> 🔍 이 문제는 다음 두 용어로 불린다. 참고로 같은 뜻이다.
> 1. 생산자 소비자 문제 (Producer - consumer problem)
>   - 생산자 소비자 문제는, 생산자 스레드와 소비자 스레드가 특정 자원을 통해 생산하고, 소비하면서 발생하는 문제이다.
> 2. 한정된 버퍼 문제 (bounded-buffer problem)
>   - 이 문제는 결국 중간에 있는 버퍼의 크기가 한정되어 있기 때문에 발생한다.

- **큐에 데이터가 없는 상황(소비자가 소비할 것이 없다)은 큐의 데이터가 가득찬 상황과 비슷하다.**
- **한정된 버퍼(bounded-buffer) 문제는 이렇듯 버퍼에 데이터가 가득 찬 상황에 데이터를 생산해서 추가할 때도 문제가 발생하고, 큐에 데이터가 없는데 데이터를 소비할 때도 문제가 발생한다.**

---

### 📚 Object - wait, notify
- synchronized를 사용한 임계 영역 안에서 락을 가지고 무한 대기하는 문제는 흥미롭게도 Object 클래스에 해결 방안이 있다.
- wait(), notify()라는 메서드를 제공하는데 이 문제를 해결할 수 있다.

1. **Object.wait()**
   - 현재 스레드가 가진 락을 반납하고 대기(WAITING)한다.
   - 현재 스레드를 대기 상태로 전환한다. 이 메서드는 현재 스레드가 synchronized 블록이나 메서드에서 락을 소유하고 있을 때만 호출할 수 있다.
   - 호출한 스레드는 락을 반납하고, 다른 스레드가 락을 획득할 수 있도록 한다.
   - 이렇게 대기 상태로 전환된 스레드는 다른 스레드가 notify() 또는 notifyAll()을 호출할 때까지 대기 상태를 유지한다.

2. **Object.notify()**
  - 대기 중인 스레드 하나를 깨운다.
  - 이 메서드는 synchronized 블록이나 메서드에서 호출되어야 한다. 깨운 스레드는 다시 락을 획득할 기회를 얻게 된다.
  - 만약 대기 중인 스레드가 여러 개라면, 그중 하나만이 깨워지게 된다. (순서는 없다.❌)

3. **Object.notifyAll()**
  - 대기 중인 모든 스레드를 깨운다.
  - 모든 대기 중인 스레드가 락을 획득할 수 있는 기회를 얻는다. 이 방법은 모든 스레드를 깨워야 할 필요가 있는 경우에 유용하다.

---

### 📚 스레드 대기 집합 (wait set)
- synchronized 임계 영역 안에서 Object.wait()를 호출하면 스레드는 대기 상태에 들어간다.
  - 이렇게 대기 상태에 들어간 스레드를 관리하는 것을 대기 집합(wait set)이라 한다.
- 참고로 모든 객체는 각자의 대기 집합을 가진다.
- 모든 객체는 락(모니터 락)과 대기 집합을 가지고 있다. 둘은 한 쌍으로 사용된다.

> 🔍 참고
> - 임계 영역의 코드를 처음으로 들어가서 실행하는 것이 아닌 대기 집합에 들어오게 된 wait()를 호출한 부분부터 실행된다.
> - 락을 획득하면 wait() 이후의 코드부터 실행한다.

---

### 📚 Object wait(), Object.notify() 한계
- notify() 메서드는 생산자가 호출 시 소비자, 생산자 스레드 중 소비자를 선택해서 깨우는 효율적인 방법이 없다.
- 둘 중 아무나 깨우기에 CPU 자원만 소모하고 다시 대기 집합에 들어갈 수 있어 비효율적이게 된다.
- 하지만 비효율적이라는 것이지 결과에는 아무 문제가 없다.

---

## 📌 정리
- 같은 스레드를 깨울 때 비효율이 발생한다.

> 스레드 기아 (thread starvation)
> - notify()의 또 다른 문제점으로는 어떤 스레드가 깨어날지 알 수 없기 때문에 발생할 수 있는 스레드 기아 문제가 있다.
> - 대기 상태의 스레드가 실행 순서를 계속 얻지 못해서 실행되지 않는 상황을 스레드 기아(thread starvation) 상태라 한다.
> - 이런 문제를 해결하는 방법 중에 notifyAll()이 있다.
> - 모든 스레드를 한 번에 깨우기 때문에 스레드 기아 상태는 면할 수 있다. 하지만 비효율은 막지 못한다.

---
