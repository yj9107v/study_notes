# 📚 Chapter 8: final

> 📌 공부 날짜: 2025/02/13
> - `JAVA `- 기본편
> - `Reference`: 인프런 - 김영한의 실전 자바

---
## ✅ final 개념
- `final` 필드를 필드에서 초기화 할 경우, 모든 인스턴스가 같은 값을 가지게 되어 메모리를 낭비하게 된다.
    - 이럴 때 `static` 을 사용함.
    - ex) static final ...
- **`final` 을 필드에서 초기화 할 경우 `static` 을 붙이는 것이 메모리 효율에 도움이 된다.**

> 🔍 상수(Constant): 변하지 않는 값
> - **특징**: `static final` 키워드 사용, 대문자만 사용하며 구분은 (`_`) 언더바 로 한다.
> - 필드를 직접 접근해서 사용한다.
> - 상수는 기능이 아니라 고정된 값 자체를 사용하는 것이 목적.
> - 예를 들어 수학에서의 상수는 파이
>   - ex) public static final double PI = 3.14;
> - 상수는 중앙에서 값을 하나로 관리 가능.

---

---

# 📚 Chapter 9: 상속

> 📌 공부 날짜: 2025/02/13
> - `JAVA `- 기본편
> - `Reference`: 인프런 - 김영한의 실전 자바

---

## ✅ 상속과 메모리 구조
- 자식 클래스 객체를 생성할 때 참조 값은 하나만 생성되지만 인스턴스 영역(Heap Area) 안에서는 부모 클래스도 함께 생성된다.
> - 외부에서 볼 때에는 하나의 인스턴스만 생성하는 거 같지만, 내부에서는 부모, 자식 클래스 둘 다 생성되고 공간도 분리된다.
> - 상속 관계의 객체를 호출할 때, 대상 타입을 정해야 하는데 이때 호출자의 타입을 통해 대상 타입을 찾는다.
> - 현재 타입에서 기능을 못 찾으면 상위 부모 타입으로 기능을 찾아서 실행한다. 찾지 못하면 컴파일 오류.

---

## ✅ 메서드 오버라이딩 (Method Overriding, 재정의)
- 부모에게서 상속 받은 기능을 자식이 재정의 하는 것을 `메서드 오버라이딩`.

### 📚 @Overriding
- @이 붙은 부분을 `애노테이션` 이라고 한다.
- 컴파일러는 이 `애노테이션`을 보고 매서드가 정확히 오버라이드 되었는지 확인한다. 안 되었을 시 컴파일 오류.
- **이 기능은 필수는 아니지만 코드의 명확성과 실수를 방지하기 위해 사용하는 것이 좋다.**

> 🔍 **오버라이딩 불가**
> - static, final, private 이 붙은 메서드는 오버라이딩 할 수 없다. (생성자도 오버라이딩 불가.)

> 🔍 **상속 관계를 이용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출해야 함.**
> - 부모에서 자식 순으로 생성자 호출이 된다.
> - 기본 생성자인 경우 super()를 생략 가능.(항상 첫 줄에만 사용할 것.)

---

## 🔍 정리
> - 클래스에 final 을 붙이면 상속 끝!
> - 메서드에 final 을 붙이면 오버라이딩 끝!

---
