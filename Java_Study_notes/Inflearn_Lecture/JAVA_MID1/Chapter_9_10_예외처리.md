# 📌 Chapter 9, 10: 예외 처리 정리 (2025/03/18)

---

## ✅ 자바에서 자원 해제의 중요성

- 자바는 **GC(Garbage Collection)** 덕분에 메모리는 자동 해제되지만,
- **외부 자원 (DB 연결, 파일 등)** 은 수동으로 해제해야 함
- `try ~ finally` 또는 `try-with-resources` 사용 권장

---

## ✅ 예외 처리 기본 개념

- 정상 흐름 + 예외 흐름이 섞이면 코드를 이해하기 어려움
- 자바는 예외를 처리하기 위한 메커니즘을 제공

### 주요 키워드
```java
try, catch, finally, throw, throws
```

### 예외 클래스 계층
- `Object`
  - `Throwable`
    - `Error`: 복구 불가 시스템 예외 (❌ 잡지 말 것)
    - `Exception`
      - `CheckedException`: 컴파일 시점 체크
      - `RuntimeException`: 언체크 예외 (컴파일러 체크 X)

---

## ✅ 예외 처리 규칙

1. 예외는 **잡거나** 또는 **밖으로 던져야** 한다
2. 지정한 예외뿐만 아니라 그 **하위 예외**도 함께 처리됨

> main() 밖으로 던지면 시스템 종료 + 스택 트레이스 출력

---

## ✅ throw vs throws

| 키워드   | 의미                                |
|----------|-------------------------------------|
| `throw`  | 새로운 예외 발생 (`throw new ...`)  |
| `throws` | 예외를 밖으로 던짐 (메서드 선언 시) |

---

## ✅ 예외 메시지와 스택 트레이스

- `super(message)` → 예외 객체 내부에 메시지 저장
- `getMessage()`: 예외 메시지 조회
- `e.printStackTrace()`: 예외 발생 지점 역추적 가능

---

## ✅ 체크 예외 vs 언체크 예외

| 항목         | 체크 예외 (Checked)     | 언체크 예외 (Runtime)       |
|--------------|--------------------------|------------------------------|
| 컴파일러 체크 | ✅ 필요                   | ❌ 생략 가능                 |
| 장점         | 안정성 높음               | 코드 간결함, 덜 번거로움     |
| 단점         | 번거롭고 코드가 길어짐    | 실수로 예외 누락 가능        |

---

## ✅ finally 블록

- `try`를 시작하기만 하면 **무조건 호출**
- 예외 발생 여부와 관계 없이 자원 해제 가능
- 보통 `close()` 호출 위치로 사용

---

## ✅ 예외 계층 활용

- 예외 계층을 잘 설계하면 **더 세밀하게 예외 처리 가능**
- 부모 catch가 자식을 포함하므로 `catch` 순서 중요

```java
catch(Child1 e) {}
catch(Child2 e) {}
catch(Parent e) {}
```

- 여러 예외를 한 번에 처리
```java
catch(Child1 | Child2 e)
```

---

## ✅ 실무 예외 처리 전략

### 문제점
- 대부분의 체크 예외는 복구 불가
- 체크 예외 → 번거롭고 throws 남발

### 해결책
- **언체크 예외(RuntimeException)** 사용
- **예외 공통 처리 메서드** 생성 (e.g., `exceptionHandler()`)

```java
catch(Exception e) {
    exceptionHandler(e);
}
```

- 예외 객체는 `instanceof` 로 타입 확인 가능

---

## ✅ try-with-resources

- 외부 자원을 자동으로 해제하는 구조
- `AutoCloseable` 구현 클래스에만 사용 가능

```java
try(Resource resource = new Resource()) {
    // 자원 사용
}
// try 끝나면 자동으로 resource.close() 호출
```

### 장점

| 장점 항목         | 설명                                      |
|-------------------|-------------------------------------------|
| 리소스 누수 방지   | finally 누락 방지                         |
| 코드 간결성       | 명시적 `close()` 불필요                   |
| 범위 한정         | 리소스 사용 범위가 `try` 블록 안으로 제한 |
| 빠른 자원 해제    | `catch` 이전에 자원 해제 가능             |

---

## ✅ 마무리 정리

- 예외는 잡거나 던져야 한다
- 실무에서는 **언체크 예외 + 공통 처리 방식** 선호
- 외부 자원은 **try-with-resources** 로 관리
- 예외 계층을 활용하면 **정밀하고 깔끔한 예외 처리** 가능
