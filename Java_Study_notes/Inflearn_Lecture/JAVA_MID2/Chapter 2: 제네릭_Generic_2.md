# 📚 (JAVA 인프런 - 중급 2편) Chapter 2: 제네릭 - Generic_2
> 공부 날짜: 2025/03/22

---

> * `자바 컴파일러`는 어떤 타입이 들어올 지 알 수 없기 때문에 T를 어떤 
> 타입이든 받을 수 있는 모든 객체의 부모인 `Object` 타입으로 가정한다. 
> 따라서 `Object`가 제공하는 메서드만 호출가능.
> * `Object`의 문제: 예시로 `Animal` 관련 제네릭 타입을 만들고 싶었지만 `Animal` 말고도 전혀 관계없는 타입을 타입 인자로 전달할 수 있는 문제가 생긴다.

---

## ✅ 타입 매개변수 제한
```java
ex)
public class Box<T extends Animal> {}
```
- 여기서 `핵심`은  `<T extends Animal>`이다.
- 타입 매개변수 T를 `Animal`과 그 자식만 받을 수 있도록 제한한다.

> - 제네릭에 타입 매개변수 상한을 사용해서 `타입 안정성`을 지키면서 상위 타입의 원하는
> 기능까지 사용할 수 있다. `코드 재사용`과 `타입 안정성` 확보.
> - 참고: `Number` 클래스는 int, double 등.

---

## ✅ 제네릭 메서드
```java
ex1) //메서드 생성
public static<T> T genericMethod(T t) {}

ex2) //메서드 선언
GenericMethod.<Integer>genericMethod(i);
```
- 제네릭 메서드는 클래스 전체가 아니라 특정 메서드 단위로 제네릭을 도입할 때 사용.
- **`핵심`은 메서드를 호출하는 시점에 타입 인자를 전달해서 타입을 지정하는 것이다.**

> `참고`
> * `제네릭 타입`은 `static` 메서드에 타입 매개변수를 사용할 수 없다.
> * `제네릭 타입`은 객체를 생성하는 시점에 타입이 결정된다.
> * `static` 메서드는 `인스턴스 단위`가 아니라 `클래스 단위`로 작동하기 때문에 제네릭 타입과는 무관한다.
> * 따라서 `static` 메서드에 제네릭을 도입하려면 제네릭 메서드를 사용해야 한다.

- 제네릭 메서드도 마차간지로 타입 매개변수 제한을 할 수 있다.
---

## ✅ 제네릭 메서드 타입 추론
- 제네릭 메서드를 호출할 때 `<Integer>`와 같이 타입 인자를 계속 전달하는 것은 불편하다.
- 자바 컴파일러는 `반환하는 타입`과 `인자에 들어간 타입`을 보고 타입 인자를 추론할 수 있다.
- `타입 인자`를 생략할 수 있다.
```java
ex) //메서드 선언 시 타입 인자 <> 생략.
Integer integer1 = GenericMethod.genericMethod(i);
```

> `제네릭 타입과 제네릭 메서드 우선순위`
> * 제네릭 메서드가 우선순위를 가진다
> * 둘의 이름이 겹치지 않게 해야 한다.

--- 

## ✅ 와일드카드 1
- 제네릭 타입을 조금 더 편리하게 사용할 수 있는 것을 `와일드카드(Wildcard)`라 한다.
- `와일드카드`라는 뜻은 컴퓨터 프로그래밍에서 `*`, `?`와 같이 하나 이상의 문자들을 상징하는 특수 문자를 뜻한다. 여러 타입이 들어올 수 있다는 뜻.
- 와일드카드는 `?`를 사용해서 정의한다. `?`는 모든 타입을 받을 수 있다는 뜻이다.
- ex) ? == <? extends Object>와 같다.

> `참고`
> * 와일드카드는 제네릭 타입이나 제네릭 메서드를 선언하는 것이 아니다.
> * 와일드카드는 이미 만들어진 제네릭 타입을 활용할 때 사용한다.

---

## ✅ 비제한 와일드카드
- 타입 인자가 정해진 제네릭 타입을 전달 받아서 활용할 때 사용한다.
- 이렇게 `?`만 사용해서 제한 없이 모든 타입을 다 받을 수 있는 와일드카드를 `비제한 와일드카드`라 한다.
```java
ex)
static void printCard(Box<?> box) {}
```

---

## ✅ 제네릭 메서드 vs 와일드카드
- `제네릭 메서드`에 타입 매개변수가 있을 때 특정 시점에 타입 매개변수에 타입 인자를 전달해서 타입을 결정해야 한다. 이러한 과정은 매우 복잡하다.
- `와일드카드`는 일반적인 메서드에 사용할 수 있고, 단순히 매개변수로 제네릭 타입을 받을 수 있는 것. `제네릭 메서드`처럼 타입을 결정하거나 복잡하게 작동하지 않는다.
> * `제네릭 타입`이나 `제네릭 메서드`를 정의하는 게 꼭 필요한 상황이 아니라면 `와일드카드` 사용을 권장.

---

## ✅ 상한 와일드카드
- `제네릭 메서드`와 마찬가지로 `와일드카드`에도 `상한 제한`을 둘 수 있다.
```java
ex) //일반 메서드에 상한 와일드카드 사용
static void printCard(Box<? extends Animal> box) {}
```
- 메서드 타입들을 특정 시점에 변경하려면 제네릭 타입이나, 제네릭 메서드를 사용해야 한다.
- `와일드카드`는 이미 만들어진 제네릭 타입을 전달 받아서 활용할 때 사용한다. 따라서 메서드의 타입들을 타입 인자를 통해 변경할 수 없다.

## ✅ 하한 와일드카드
```java
ex)
static void printCard(Box<? super Animal> box) {}
```
- `?`가 `Animal` 타입을 포함한 상위 타입만 입력받을 수 있다.

---

## ✅타입 이레이저
- **제네릭은 자바 컴파일 단계에서만 적용되고, 컴파일 이후에는 제네릭 정보가 삭제된다.**
- 컴파일 전인 `java`에는 제네릭의 타입 매개변수가 존재하지만 후에는 `.class`로 타입 매개변수가 존재하지 않는다.
- 값을 반환하는 부분을 `Object`로 받으면 안 된다.

> 1. `타입 매개변수 제한의 경우`
> * 타입 매개변수를 제한하면 제한한 타입으로 컴파일 후 코드를 변경한다.

- `자바의 제네릭`은 개발자가 직접 캐스팅하는 코드를 컴파일러가 대신 처리해주는 것이다.
- **`자바의 제네릭 타입`은 컴파일 시점에만 존재하고, 런타임 시에는 제네릭 정보가 지워지는데, 이것을 `타입 이레이저`라고 한다.**

---

## ✅ 타입 이레이저 방식의 한계
- 런타임에 타입을 활용하는 코드를 작성할 수 없다.
- 제네릭 타입은 다 `Object`가 되기 때문에 `instance of`나 `return new T();`를 사용할 수 없다.

---
