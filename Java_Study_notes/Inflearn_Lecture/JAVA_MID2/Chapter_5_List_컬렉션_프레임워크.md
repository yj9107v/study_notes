# 📚 (JAVA 인프런 - 중급 2편) Chapter 5: 컬렉션 프레임워크 - List
> 📌 공부 날짜: 2025/03/27

---
- 다형성과 OCP 원칙을 가장 잘 활용할 수 있는 곳 중에 하나가 바로 자료구조이다.

## ✅ 의존관계 주입(Dependency Injection, DI)
```java
ex) private final MyList<Integer> list; // 여기서 MyList는 인터페이스이다.
```
- 이렇게 선언하면 외부에 생성자를 통해서 `MyList`의 구현체가 전달된다.
    - `MyArrayList`의 인스턴스가 들어올 수 있고, `MyLinkedList`가 들어올 수도 있다.
- 예시를 선언한 클래스의 외부에서 의존관계가 결정되어서 예시 클래스의 인스턴스에 들어오는 것 같다. 마치 의존관계가 주입되는 것 같다고 하여 이것을 `의존관계 주입`이라고 한다.

### 🔍 1. 컴파일 타임 의존관계
- 자바 컴파일러가 보는 의존관계이다. 클래스에 모든 의존관계가 나타난다.
- 실행하지 않은 소스 코드에 정적으로 나타나는 의존관계이다.

### 🔍 2. 런타임 의존관계
- 실제 프로그램이 작동할 때 보이는 의존관계다. 주로 생성된 인스턴스와 그것을 참조하는 의존관계이다.
- 런타임 의존관계는 실행 중에 계속 변할 수 있다.

> 📌 정리
> - 의존관계를 클래스에서 미리 결정하는 것이 아닌, 런타임에 객체를 생성하는 시점으로 미룬다.
> - 이렇게 생성자를 통해 런타임 의존관계를 주입하는 것을 `의존관계 주입` 또는 줄여서 `생성자 주입`이라고 한다.
> - 클라이언트 클래스는 컴파일 타임에 추상적인 것에 의존하고, 런타임에 의존관계 주입을 통해 구현체를 주입받아 사용한다.
> - 클라이언트 클래스는 코드 변경이 일어나지 않는 이점이 발생.

> 📚 전략 패턴(Strategy Pattern)
> - 알고리즘을 클라이언트 코드의 변경 없이 쉽게 교체할 수 있다.

---

## ✅ 자바에서 제공하는 리스트

### 🔍 1. Collection 인터페이스
- java.util 패키지의 컬렉션 프레임워크의 핵심 인터페이스 중 하나이다.
- 이 인터페이스는 자바에서 다양한 컬렉션, 즉 데이터 그룹을 다루기 위한 메서드를 정의한다.
- `Collection` 인터페이스는 `List`, `Set`, `Queue`와 같은 다양한 하위 인터페이스와 함께 사용되며, 이를 통해 데이터를 리스트, 세트, 큐 등의 형태로 관리할 수 있다.

### 🔍 2. List 인터페이스
- java.util 패키지에 있는 컬렉션 프레임워크의 일부다. `List`는 객체들의 순서가 있는 컬렉션을 나타내며, 같은 객체의 중복 저장을 허용한다.
- 이 리스트는 배열과 비슷하지만, 크기가 동적으로 변화하는 컬렉션을 다룰 때 유용하게 사용한다.
- `ArrayList`, `LinkedList`와 같은 여러 구현 클래스를 가지고 있으며, 각 클래스는 `List` 인터페이스의 메서드를 구현한다.

---

## ✅ 자바에서 제공한 ArrayList
- java.util.ArrayList

> 🔍 특징
> - 배열을 사용해서 데이터를 관리한다.
> - 기본 `CAPACITY`는 10이다.
>   - `CAPACITY`를 넘어가면 배열을 50% 증가한다.
> - 메모리 고속 복사 연산을 사용한다.
>   - `ArrayList`의 중간 위치에 데이터를 추가하면, 추가할 위치 이후의 모든 요소를 한 칸씩 뒤로 이동시켜야 한다.
>   - 자바가 제공하는 `ArrayList`는 이 부분을 최적화 하는데, 배열의 요소 이동은 시스템 레벨에서 최적화된 메모리 고속 복사 연산을 사용해서 비교적 빠르게 수행된다.
>   - 참고로 `System.arrayCopy()`를 사용한다.
>   - 메모리 고속 복사라 하더라도 데이터가 아주 많으면 느려진다.

---

## ✅ 자바 LinkedList
- java.util.LinkedList

> 🔍 특징
> - 이중 연결 리스트 구조
> - 첫 번째 노드와 마지막 노드 둘 다 참조
> - 데이터를 마지막에 추가하는 경우에도 `O(1)`의 성능을 제공한다.
> - 이전 노드로 이동할 수 있기 때문에 마지막 노드부터 앞으로, 즉 역방향 조회할 수 있다.
> - 덕분에 인덱스 조회 성능을 최적화 할 수 있다.

---

## ✅ 자바 리스트의 성능 비교

### 🔍 1. 추가, 삭제
- `배열 리스트`는 인덱스를 통해 추가나 삭제할 위치를 `O(1)`로 빠르게 찾지만, 추가나 삭제 이후 데이터를 한 칸씩 밀어야 한다. 이 부분이 `O(n)`으로 오래 걸린다.
- `연결 리스트`는 인덱스를 통해 추가나 삭제할 위치를 `O(n)`으로 느리게 찾지만, 실제 데이터의 추가는 간단한 참조 변경으로 `O(1)`이 걸린다.

### 🔍 2. 인덱스 조회
- `배열 리스트`: 배열에 인덱스를 사용해서 값을 `O(1)`로 찾을 수 있다.
- `연결 리스트`: 노드를 인덱스 수 만큼 이동해야 한다. `O(n)`

### 🔍 3. 검색
- 배열, 연결 리스트 둘 다 데이터를 찾을 때까지 순회해야 한다. `O(n)`

### 🔍 시간 복잡도와 실제 성능
- 이론적으로 중간 삽입은 `LinkedList`가 `ArrayList`보다 빠를 수 있다.
- 그러나 실제 성능은 요소의 순차적 접근 속도, 메모리 할당 및 해제 비용, CPU 캐시 활용도 등 다양한 요소에 의해 영향을 받는다.
- `ArrayList`는 요소들이 메모리 상에서 연속적으로 위치하여 CPU 캐시 효율이 좋고, 메모리 접근 속도가 빠르다.
- 반면, `LinkedList`는 각 요소가 별도의 객체로 존재하고 다음 요소의 참조를 저장하기 때문에 CPU 캐시 효율이 떨어지고, 메모리 접근 속도가 상대적으로 느려질 수 있다.

> 📌 정리
> - `ArrayList`가 실제 환경에서 더 나은 성능을 보여주는 경우가 많다.
> - 실무에서는 주로 `ArrayList`를 사용하고, 만약 데이터를 앞쪽에서 자주 추가하거나 삭제할 일이 있다면 연결 리스트를 고려하자.

---
