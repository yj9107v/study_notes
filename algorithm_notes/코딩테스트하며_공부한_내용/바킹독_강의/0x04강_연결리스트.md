# 📚 실전 알고리즘 0x04강 - 연결 리스트

> 📌 공부 날짜: 2025/07/24
> - `References`: [바킹독의 실전 알고리즘](https://blog.encrypted.gg/category/%EA%B0%95%EC%A2%8C/%EC%8B%A4%EC%A0%84%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

---

## ✅ 정의와 성질
- 연결 리스트가 무엇인가 하면, 원소들을 저장할 때 그다음 원소가 있는 위치를 포함시키는 방식으로 저장하는 자료구조이다.
  - 원소들은 이곳저곳에 흩어져 있다.

#### 🔍 연결 리스트의 성질
1. k번째 원소를 확인/변경하기 위해 O(k)가 필요함
2. 임의의 위치에 원소를 추가/임의 위치의 원소 제거는 O(1)
3. 원소들이 메모리 상에 연속해 있지 않아 Cache hit rate가 낮지만 할당이 다소 쉬움

#### 🔍 연결 리스트의 종류
1. 단일 연결 리스트 (Singly Linked List)
  - 각 원소가 자신의 다음 원소의 주소를 들고 있는 연결 리스트이다.
2. 이중 연결 리스트 (Doubly Linked List)
  - 각 원소가 자신의 이전 원소와 다음 원소의 주소를 둘 다 들고 있다.
  - 단일 연결 리스트에서는 주어진 원소의 이전 원소가 무엇인지를 알 수 없는데 이중 연결 리스트에서는 알 수 있다.
  - 다만 원소가 가지고 있어야 하는 정보가 1개 더 추가되니 메모리를 더 쓴다는 단점.
3. 원형 연결 리스트 (Circular Linked List)
  - 끝이 처음과 연결되어 있다.


- 배열과 연결 리스트는 메모리 상에 원소를 놓는 방법은 다르다고 해도 어찌 됐든 원소들 사이의 선후 관계가 일대일로 정의가 된다.
  - 즉, 원소들 사이에서 첫 번째 원소, 두 번째 원소... 이런 개념이 존재하는 것이다.
- 그래서 배열과 연결 리스트는 선형 자료구조라고 불린다.
  - 트리, 그래프, 해쉬 등은 비선형 자료구조의 대표적인 예시이다.


- 배열과 연결 리스트는 둘 다 선형 자료구조여서 면접에서 둘의 비교하는 문제를 구술시험으로 내기도 한다.
- 첫 번째로 k번째 원소의 접근은 배열의 경우 O(1), 연결 리스트의 경우 O(k)입니다.
- 두 번째로 임의의 위치에 원소를 추가하거나 제거하는 건 배열의 경우 O(N), 연결 리스트의 경우 O(1)입니다.
  - 하지만 엄밀히 말해서 연결 리스트에서도 3번째 원소 뒤에 20이라는 원소를 추가하고 싶다고 하면, 일단 3번째 원소까지는 찾아간 뒤에야 O(1)에 추가가 가능한 거라, 시간 복잡도가 O(N)이 나온다.
  - 추가하고 싶은 위치의 주소를 알고 있을 경우에만 O(1)인 것이다.
  - 임의 위치의 원소를 제거할 때, 메모리 누수를 막기 위해 메모리에서 없애줄 필요가 있다.
- 메모리 상의 배치는 배열의 경우 연속이고, 연결 리스트의 경우 불연속이다.
- 마지막으로 추가적으로 필요한 공간, 즉 overhead를 생각해 보면 배열은 데이터만 딱딱 저장하면 될 뿐 딱히 추가적을 필요한 공간이 없다.
  - 그런데 연결 리스트에서는 각 원소가 다음 원소, 혹은 이전과 다음 원소의 주소 값을 가지고 있어야 한다.
  - 그래서 32비트 컴퓨터면 주소 값이 32비트(=4바이트) 단위이니 4N 바이트가 추가로 필요하고, 64비트 컴퓨터라면 주소 값이 64비트(=8바이트) 단위이니 8N 바이트가 추가로 필요하게 된다.
  - 즉 N에 비례하는 만큼의 메모리를 추가로 쓰게 된다.


#### 🔍 연결 리스트 자료구조를 사용하는 예시
- 메모장과 같은 텍스트 에디터이다.
- 임의의 위치에서 원소를 추가하거나 임의 위치의 원소를 제거하는 연산을 많이 해야 할 경우에는 연결 리시트의 사용을 고려해 보자.

### 📚 손코딩 문제 1
#### 🔍 원형 연결 리스트 내의 임의의 노드 하나가 주어졌을 때 해당 List의 길이를 효율적으로 구하는 방법?
- 동일한 노드가 나올 때까지 계속 다음 노드로 가면 됨. 공간복잡도 O(1), 시간복잡도 O(N)

---
#### 🔍 중간에 만나는 두 연결 리스트의 시작점들이 주어졌을 때 만나는 지점을 구하는 방법?
- 일단 두 시작점 각각에 대해 끝까지 진행시켜서 각각의 길이를 구함.
- 그 후 다시 두 시작점으로 돌아와서 더 긴 쪽을 둘의 차이만큼 앞으로 먼저 이동시켜 놓고, 두 시작점이 만날 때까지 두 시작점을 동시에 한 칸씩 전진시키면 됨.
- 공간복잡도 O(1), 시간복잡도 O(A+B)

---
#### 🔍 주어진 연결 리스트 안에 사이클이 있는지 판단하라 - (주어진 연결 리스트는 바킹독 사이트 사진 참고)
- Floyd's cycle-finding algorithm, 공간복잡도 O(1), 시간복잡도 O(N)
- 한 칸씩 가는 커서와 두 칸씩 가는 커서를 시작점에서 출발시키면 사이클이 있을 경우 두 커서는 반드시 만나게 된다.
- 반대로 만약 사이클이 없으면 두 커서가 만나지 못하고 연결 리스트의 끝에 도달한다.
- 이 방식을 이용하면 거치는 모든 노드를 저장할 필요 없이 공간복잡도 O(1)에 사이클의 존재 여부를 알 수 있다.