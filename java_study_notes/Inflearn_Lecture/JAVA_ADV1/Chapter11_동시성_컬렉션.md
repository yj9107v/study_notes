# 📚 Chapter 11: 동시성 컬렉션

> 📌 공부 날짜: 2025/04/29
> - `JAVA `- 고급 1편
> - `Reference`: 인프런 - 김영한의 실전 자바

---
## ✅ 동시성 컬렉션이 필요한 이유
> 🔍참고: 여러 스레드가 동시에 접근해도 괜찮을 경우 스레드 세이프(Thread Safe)하다고 한다.

- 컬렉션 프레임워크가 제공하는 대부분의 연산은 원자적인 연산이 아니다.
- 단일 스레드가 컬렉션에 접근하는 경우라면 아무런 문제가 없지만, 멀티스레드 상황에서 여러 스레드가 동시에 컬렉션에 접근하는 경우라면 java.util 패키지가 제공하는 일반적인 컬렉션들을 사용하면 안 된다.

### 📚 해결 방안
1. synchronized, Lock 등을 통해 안전한 임계 영역을 적절히 만들면 문제 해결 가능.
    - 하지만 이렇게 되면 모든 컬렉션을 다 복사해서 동기화 용으로 새로 구현해야 한다.
    - 이것은 매우 비효율적이다.

2. 프록시 도입
    - 우리말로 대리자, 대신 처리해 주는 자라는 뜻이다.
    - 객체 세상에도 이런 프록시를 만들 수 있다. 여기서는 프록시가 대신 동기화(synchronized) 기능을 처리해 주는 것이다.
    ```java
    public class SyncProxyList implements SimpleList {
   
        private SimpleList target;
   
        public SyncProxyList(SimpleList target) {
            this.target = target;
        }
   
        @Override
        public synchronized void add(Object e) {
            targer.add(e);
        }
    }
    test(new SyncProxyList(new BasicList));
    ```
    - 프록시 역할을 하는 클래스이다.
    - 클라이언트 입장에서 보면 프록시는 원본과 똑같이 생겼고, 호출할 메서드도 똑같다.
    - 프록시는 내부에 원본을 가지고 있다. 그래서 프록시가 필요한 일부의 일을 처리하고, 그다음에 원본을 호출하는 구조를 만들 수 있다.
    - 프록시가 동기화를 적용하고 원본을 호출하기 때문에 원본 코드도 이미 동기화가 적용된 상태로 호출된다.
    - **여기서 중요한 핵심은 원본 코드인 BasicList를 전혀 손대지 않고, 프록시인 SyncProxyList를 통해 동기화 기능을 적용했다는 점이다.**
      - SyncProxyList 프록시 하나로 SimpleList 인터페이스의 모든 구현체를 동기화할 수 있다.

---

### 📚 프록시 패턴 (Proxy Pattern)
- 프록시 패턴은 객체지향 디자인 패턴 중 하나로, 어떤 객체에 접근을 제어하기 위해 그 객체의 대리인 또는 인터페이스 역할을 하는 객체를 제공하는 패턴이다.
- 프록시 객체는 실제 객체에 대한 참조를 유지하면서, 그 객체에 접근하거나 행동은 수행하기 전에 추가적인 처리를 할 수 있도록 한다.

> 🔍 프록시 패턴의 주요 목적
> - 접근 제어: 실제 객체에 대한 접근을 제한하거나 통제할 수 있다.
> - 성능 향상: 실제 객체의 생성을 지연시키거나 캐싱하여 성능을 최적화할 수 있다.
> - 부가 기능 제공: 실제 객체에 추가적인 기능(로깅, 인증, 동기화 등)을 투영하게 제공할 수 있다.

- **실무에서 프록시 패턴은 자주 사용된다. 스프링의 AOP 기능은 사실 이런 프록시 패턴을 극한으로 적용하는 예이다.**

---

### 📚 자바 동시성 컬렉션 - synchronized
- synchronized를 대신 적용해 주는 프록시를 만드는 방법이 있다.
- List, Set, Map 등 주요 인터페이스를 구현해서 synchronized를 적용할 수 있는 프록시를 만들면 된다.
- 자바는 컬렉션을 위한 프록시 기능을 제공한다.

```java
List<String> list = Collections.synchronizedList(new ArrayList<>());
```
- Collections는 다양한 synchronized 동기화 메서드를 지원한다. 이 메서드를 사용하면 List, Map, Set, Collection 등 다양한 동기화 프록시를 만들어낼 수 있다.
- **Collections가 제공하는 동기화 프록시 기능 덕분에 스레드 안전하지 않은 수많은 컬렉션들을 매우 편리하게 스레드 안전한 컬렉션으로 변경해서 사용할 수 있다.**

#### 🤔 synchronized 프록시 방식의 단점
1. 동기화 오버헤드 발생
   - 각 메서드 호출 시마다 동기화 비용이 추가된다. 이로 인해 성능 저하가 발생한다.

2. 전체 컬렉션에 대해 동기화가 이루어지기 때문에, 잠금 범위가 넓어질 수 있다.
   - 이는 잠금 경합(lock connection)을 증가시키고, 병렬 처리의 효율성을 저하시키는 요인이 된다.

3. 정교한 동기화가 불가능하다.
   - 특정 부분이나 메서드에 대해 선택적으로 동기화를 적용하는 것은 어렵다.
     - 이는 과도한 동기화로 이어질 수 있다.

- 자바는 이러한 단점을 보완하기 위해 java.util.concurrent 패키지에 동시성 컬렉션(concurrent collection)을 제공한다.

---

## ✅ 동시성 컬렉션
- 스레드 안전한 컬렉션
- 이 컬렉션들은 더 정교한 잠금 메커니즘을 사용하여 동시 접근을 효율적으로 처리하며, 필요한 경우 일부 메서드에 대해서만 동기화를 적용하는 등 유연한 동기화 전략을 제공한다.
- 여기서 다양한 성능 최적화 기법들이 적용되어 있는데, synchronized, Lock(ReentrantLock), CAS, 분할 잠금 기술(segment lock) 등 다양한 방법을 섞어서 매우 정교한 동기화를 구현해서 동시에 성능도 최적화한다.

### 📚 동시성 컬렉션 종류
1. List -> CopyOnWriteArrayList

2. Set
   - CopyOnWriteArraySet -> HashSet의 대안
   - ConcurrentSkipListSet -> TreeSet의 대안 (정렬된 순서 유지, Comparator 사용 가능)

3. Map
   - ConcurrentHashMap
   - ConcurrentSkipListMap -> TreeMap의 대안 (정렬된 순서 유지, Comparator 사용 가능)

4. Queue -> ConcurrentLinkedQueue: 동시성 큐, 비 차단(non-blocking) 큐이다.

5. Deque -> ConcurrentLinkedDeque: 동시성 데크. 비 차단(non-blocking) 큐이다.

- 참고로 LinkedHashSet, LinkedHashMap처럼 입력 순서를 유지하는 동시에 멀티스레드 환경에서 사용할 수 있는 Set, Map 구현체는 제공하지 않는다.
  - 필요하다면 프록시 사용.
- 스레드를 차단하는 블로킹 큐도 있다. (11장 21p 확인)

---

## 📌 정리
- 자바가 제공하는 동시성 컬렉션은 멀티스레드 상황에 최적의 성능을 낼 수 있도록 다양한 최적화 기법이 적용되어 있다.
- 따라서 Collections.synchronizedXxx를 사용하는 것보다 더 좋은 성능을 제공한다.
- 동시성은 결국 성능과 트레이드오프가 있다. 따라서 단일 스레드가 컬렉션을 사용하는 경우에는 동시성 컬렉션이 아닌 일반 컬렉션을 사용해야 한다.
- 반대로 멀티스레드 상황에서 일반 컬렉션을 사용하면 정말 해결하기 어려운 버그를 만날 수 있다.
- 세상에 제일 어려운 버그이기에 멀티스레드 환경에서는 동시성 컬렉션을 적절히 활용해서 버그를 예방하고 성능을 최적화하는 것이 중요하다.
  - 동시성 컬렉션은 사용하면 코드의 안정성과 효율성을 높일 수 있으며, 예상치 못한 동시성 문제도 방지할 수 있다.

---