# 📚 Chapter 13: 스레드 풀과 Executor 프레임워크 2

> 📌 공부 날짜: 2025/05/05
> - `JAVA `- 고급 1편
> - `Reference`: 인프런 - 김영한의 실전 자바

---

## ✅ ExecutorService 우아한 종료 - 소개
> 🤔 예시)
> - 고객의 주문을 처리하는 서버를 운영 중이라고 가정하자.
> - 만약 서버 기능을 업데이트해서 서버를 재시작해야 한다고 할 때, 이때 서버 애플리케이션 고객의 주문을 처리하고 있는 도중에 갑자기 재시작된다면,
> 해당 고객의 주문이 제대로 진행되지 못할 것이다.
> - 가장 이상적인 방향은 새로운 주문 요청을 막고, 이미 진행 중인 주문은 모두 완료한 다음에 서버를 재시작하는 것이 가장 좋은 것이다.
> - 이처럼 서비스를 안정적으로 종료하는 것도 매우 중요하다.
> - 이렇게 문제없이 우아하게 종료하는 방식을 `grateful shutdown`이라 한다.

### 📚 ExecutorService의 종료 메서드
1. **void shutdown()**
    - 새로운 작업을 받지 않고, 이미 제출된 작업을 모두 완료한 후에 종료한다.
    - 논 블로킹 메서드 이 메서드를 호출한 스레드는 대기하지 않고 즉시 다음 코드를 호출한다.

2. **List<Runnable> shutdown()**
    - 실행 중인 작업을 중단하고, 대기 중인 작업을 반환하여 즉시 종료한다.
    - 실행 중인 작업을 중단하기 위해 인터럽트를 발생시킨다.
    - 논 블로킹 메서드

#### 🔍 서비스 상태 확인 메서드
1. **boolean isShutdown()**
    - 서비스가 종료되었는지 확인한다.

2. **boolean isTerminated()**
    - shutdown, shutdownNow() 호출 후, 모든 작업이 완료되었는지 확인한다.

#### 🔍 작업 완료 대기 메서드
1. **boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException**
    - 서비스 종료 시 모든 작업이 완료될 때까지 대기한다. 이때 지정된 시간까지만 대기한다.
    - 블로킹 메서드

2. **close()**
    - 자바 19부터 지원하는 서비스 종료 메서드이다. 이 메서드는 shutdown()과 같다고 생각하면 된다.
      - 더 정확히는 shutdown()을 호출하고, 하루를 기다려도 작업이 완료되지 않으면 shutdown()를 호출한다.
    - 호출한 스레드에 인터럽트가 발생해도 shutdownNow()를 호출한다.

- **ExecutorService가 새로운 요청을 거절 시 기본적으로 java.util.RejectExecutionException 예외가 발생한다.**

---

## ✅ ExecutorService 우아한 종료 - 구현
- shutdown()을 호출해서 이미 들어온 모든 작업을 다 처리하고 서비스를 우아하게 종료(grateful shutdown)하는 것이 가장 이상적이지만,
 갑자기 요청이 너무 많이 들어와서 큐에 대기 중인 작업이 너무 많아 완료가 어렵거나, 작업이 너무 오래 걸리거나, 또는 버그가 발생해서 특정 작업이 끝나지 않을 수 있다.
  - 이렇게 되면 서비스가 너무 늦게 종료되거나, 종료되지 않는 문제가 발생할 수 있다.

>❗해결
> - 이럴 때는 보통 우아하게 종료하는 시간을 정한다. 예를 들어서 60초까지는 작업을 다 처리할 수 있게 기다리는 것이다.
> - 그리고 60초가 지나면, 무언가 문제가 있다고 가정하고 shutdownNow()를 호출해서 작업들을 강제로 종료한다.
> - close()의 경우 이렇게 구현되어 있지만, 하루를 기다린다. 대부분 하루를 기다릴 수는 없을 것이다.
> - 참고로 구현할 shutdownAndAwaitTermination()는 ExecutorService 공식 API 문서에서 제안하는 방식이다.

```java
static void shutdownAndAwaitTermination(ExecutorService es) {
    es.shutdown();
    
    try {
        log("서비스 정상 종료 시도");
        if (!es.awaitTermination(60, TimeUnit.SECONDS)) {
            log("서비스 정상 종료 실패 -> 강제 종료 시도");
            es.shutdownNow();
            if (!es.awaitTermination(60, TimeUnit.SECONDS)) {
                log("서비스가 종료되지 않았습니다.");
            }
        }
    } catch (InterruptedException e) {
        es.shutdownNow();
    }
}
```
- **서비스 종료 실패**
  - 그런데 마지막에 강제 종료인 es.shutdownNow()를 호출한 다음에 왜 60초간 또 기다릴까?
  - shutdownNow()가 작업 중인 스레드에 인터럽트를 호출하는 것은 맞다.
  - 인터럽트를 호출하더라도 여러 가지 이유로 작업에 시간이 걸릴 수도 있다.
  - 인터럽트 이후에 자원을 정리하는 어떤 간단한 작업을 수행할 수도 있다.
  - 이런 시간을 기다려주는 것이다.


- 극단적이지만 최악의 경우 스레드가 다음과 같이 인터럽트를 받을 수 없는 코드를 수행 중일 수도 있다.
  - 이 경우 인터럽트 예외가 발생하지 않고, 스레드도 계속 수행된다.
  - ex) 인터럽트를 받을 수 없는 코드
    - while (true) {}
    - 이런 스레드는 자바를 강제 종료해야 제거할 수 있다.


- 이런 경우를 대비해서 강제 종료 후 60초간 대기하고 작업이 완료되지 않으면 "서비스 종료되지 않았습니다"라고 개발자가 인지할 수 있는 코드를 남겨두어야 한다.
- 그래야 개발자가 나중에 문제를 찾아서 코드를 수정할 수 있다.

> 📌정리
> - 서비스를 종료할 때 생각보다 고려해야 할 점이 많다.
> - 기본적으로 우아한 종료를 선택하고, 우아한 종료가 되지 않으면 무한정 기다릴 수는 없으니, 그다음으로 강제 종료를 하는 방식으로 접근하는 것이 좋다.

---

## ✅ Executor 스레드 풀 관리 - 코드
- Executor 프레임워크가 어떤 식으로 스레드를 관리하는지 알아보자.
```java
ExecutorService es = new ThreadPoolExecutor(2, 4, 3000, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(2)); 
```
> 🔍 코드 설명
> - 작업을 보관할 블로킹 큐의 구현체로 ArrayBlockingQueue(2)를 사용했다.
>   - 사이즈를 2로 설정했으므로 최대 2개까지 작업을 큐에 보관할 수 있다.
> - corePoolSize = 2, maximumPoolSize = 4를 사용해서 기본 스레드는 2개, 최대 스레드는 4개로 설정했다.
>   - 스레드는 풀에 기본 2개의 스레드를 운영한다. 요청이 너무 많거나 급한 경우 스레드 풀은 최대 4개까지 스레드를 증가시켜서 사용할 수 있다.
>   - 이렇게 기본 스레드 수를 초과해서 만들어진 스레드를 `초과 스레드`라 한다.
> - 3000, TimeUnit.MILLISECONDS
>   - 초과 스레드가 생존할 수 있는데 대기 시간을 뜻한다. 이 시간 동안 초과 스레드가 처리할 작업이 없다면 초과 스레드는 제거된다.

- 🔍 분석
  - 스레드 풀의 스레드 수가 core 사이즈(2)를 넘아가면 작업을 큐에 보관한다.
  - 기본 스레드는 2개, 보관할 수 있는 큐의 크기는 2개이다.
  - 현재 2개의 작업이 실행 중이고, 2개의 작업이 추가로 들어와 큐도 가득 차게 된 상태에서 5번째 작업이 추가로 들어올 경우 이때 max 사이즈(4)까지는 추가 스레드를 생성해서 수행한다.
  - 기본 스레드 2개에 max 사이즈가 4이므로 초과 스레드는 2개 더 만들어서 작업을 수행할 수 있다.
  - 그리하여 총 6개의 작업이 기본 스레드 2, 초과 스레드 2, 큐 보관 2로 되어 모든 작업을 예외 없이 작업할 수 있다.
  - 만약 이 상황에 7번째 작업이 들어오게 되면 RejectedExecutionException 실행 거절 예외가 발생한다.
    - 이 경우에 큐에 넣을 수도, 작업을 수행할 스레드도 만들 수 없기 때문에 작업을 거절한 것이다.
  - 작업을 모두 수행한 후에 초과 스레드들이 지정된 시간 3초 동안 작업을 하지 않고 대기하면 제거한다.
    - 긴급한 작업들이 끝난 것으로 이해하면 된다.
  - 참고로 초과 스레드가 작업을 처리할 때마다 시간은 계속 초기화된다.
  - 이후에 shutdown()이 진행되면 풀의 스레드도 모두 제거된다.

> 📌 정리
> 1. 작업을 요청하면 core 사이즈만큼 스레드를 만든다.
> 2. core 사이즈를 초과하면 큐에 작업을 넣는다.
> 3. 큐를 초과하면 max 사이즈만큼 스레드를 만든다. 임시로 사용되는 초과 스레드가 생성된다.
>   - 큐가 가득 차서 큐에 넣을 수도 없다. 초과 스레드가 바로 수행해야 한다.
> 4. max 사이즈를 초과하면 요청을 거절한다. 예외가 발생한다.
>   - 큐가 가득 차고, 풀에 최대 생성 가능한 스레드 수도 가득 찼다. 작업을 받을 수 없다.

---

### 📚 스레드 미리 생성하기
- 응답 시간이 아주 중요한 서버라면, 서버가 고객의 처음 요청을 받기 전에 스레드를 스레드 풀에 미리 생성해두고 싶을 수 있다.
- 스레드를 미리 생성해 두면, 처음 요청에서 사용되는 스레드의 생성 시간을 줄일 수 있다.
- ThreadPoolExecutor.preStartAllCoreThreads()를 사용하면 기본 스레드를 미리 생성할 수 있다.
- 참고로 ExecutorService는 이 메서드를 제공하지 않는다.

---

## ✅ Executor 전략
### 📚 Executor 스레드 풀 관리 - 다양한 전략
- ThreadPoolExecutor를 사용하면 스레드 풀에 사용되는 숫자와 블로킹 큐등 다양한 속성을 조절할 수 있다.
- 속성들을 조절하면 자신에게 맞는 스레드 풀 전략을 사용할 수 있다.
- 자바는 Executor 클래스를 통해 3가지 기본 전략을 제공한다.
  - 1. newSingleThreadPool(): 단일 스레드 풀 전략
  - 2. newFixedThreadPool(nThreads): 고정 스레드 풀 전략
  - 3. newCachedThreadPool(): 캐시 스레드 풀 전략
---

#### 🔍 1. newSingleThreadPool(): 단일 스레드 풀 전략
- 스레드 풀에 기본 스레드 1개만 사용한다.
- 큐 사이즈에 제한이 없다. (LinkedBlockingQueue)
- 주로 간단히 사용하거나, 테스트 용도로 사용한다.
```java
new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
``` 
---

#### 🔍 2. newFixedThreadPool(nThreads): 고정 스레드 풀 전략
- 스레드 풀에 nThreads 만큼의 기본 스레드를 생성한다. 초과 스레드는 생성하지 않는다.
- 큐 사이즈에 제한이 없다. (LinkedBlockingQueue)
- 스레드 수가 고정되어 있기 때문에 CPU, 메모리 리소스가 어느 정도 예측 가능한 안정적인 방삭이다
```java
new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
```
- ❗ 특징
  - 스레드 수가 고정되어 있기 때문에 CPU, 메모리 리소스 어느 정도 예측 가능한 안정적인 방식이다.
  - 큐 사이즈도 제한이 없어서 작업을 많이 담아두어도 문제가 없다.

> 🚨주의
> - 이 방식의 가장 큰 단점은 스레드 수가 고정되어서 CPU, 메모리 리소스가 어느 정도 예측 가능하다는 점이다.
> - 따라서 일반적인 상황에 가장 안정적으로 서비를 운영할 수 있다.
> - 하지만 상황에 따라 장점이 가장 큰 단점이 된다.

- 상황 1 - 점진적 확대
  - 사용자가 점점 늘어난다.
  - 고정 스레드 전략을 사용해서 서비스를 안정적으로 잘 운영했는데, 언젠가부터 사용자들이 서비스 응답이 점점 느려진다고 항의한다.


- 상황 2 - 갑작스러운 요청 증가
  - 마케팅 팀의 이벤트가 대성공하면서 갑자기 사용자가 폭증했다.
  - 고객은 응답을 받지 못한다고 항의한다.

> 🤔 확인
> - 고정 스레드 전략은 실행되는 스레드 수가 고정되어 있다 보니, 사용자가 늘어나도 CPU, 메모리 사용량이 확 늘어나지 않는다.
> - 큐의 사이즈를 확인해 보니 요청이 수만 건이 쌓여있다. 요청이 처리되는 시간보다 쌓이는 시간이 더 빠른 것이다.
> - 서비스 초기에는 사용자가 적기 때문에 이런 문제가 없지만, 사용자 늘어나면 문제가 될 수 있다.
> - 갑작스러운 요청 증가도 물론 마찬가지이다.

- **결국 서버 자원은 여유가 있는데, 사용자만 점점 느려지는 문제가 발생한 것이다.**

---

#### 🔍 3. newCachedThreadPool(): 캐시 스레드 풀 전략
- 기본 스레드를 사용하지 않고, 60초 생존 주기를 가진 초과 스레드만 사용한다.
- 초과 스레드의 수는 제한이 없다.
- 큐에 작업을 저장하지 않는다. (SynchronousQueue)
  - 대신에 생산자의 요청을 스레드 풀의 소비자 스레드가 직접 받아서 바로 처리한다.
- 모든 요청이 대기하지 않고 스레드가 바로바로 처리한다. 따라서 빠른 처리가 가능하다.

```java
new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
```
- SynchronousQueue는 아주 특별한 블로킹 큐이다.
  - BlockingQueue 인터페이스의 구현체 중 하나이다.
  - 이 큐는 내부에 저장 공간이 없다. 대신에 생산자의 작업을 소비자 스레드에게 직접 전달한다.
  - 쉽게 이야기해서 저장 공간의 크기가 0이고, 생산자 스레드 큐가 작업을 전달하면 소비자가 스레드 큐에서 작업을 꺼낼 때 대기한다.
  - 소비자가 작업을 요청하면 기다리던 생산자가 소비자에게 직접 작업을 전달하고 반환된다. 그 반대의 경우도 같다.
  - 이름 그대로 생산자와 소비자를 동기화하는 큐이다.
  - 중간에 버퍼를 두지 않는 스레드 간 직거래라고 생각하면 된다.

> ❗ 특징
> - 캐시 스레드 풀 전략은 매우 빠르고, 유연한 전략이다.
> - 초과 스레드의 수가 제한이 없기 때문에 CPU, 메모리 자원만 허용된다면 시스템의 자원을 최대로 사용할 수 있다.
> - 추가로 초과 스레드는 60초간 생존하기 때문에 작업 수에 맞추어 적절한 수의 스레드가 재사용된다.
>   - 이런 특징 때문에 요청이 갑자기 증가하면 스레드도 갑자기 증가하고, 요청이 줄어들면 스레드도 점점 줄어든다.
> - 이 전략은 작업의 요청 수에 따라서 스레드도 증가하고 감소하므로, 매우 유연한 전략이다.

> 🚨 주의
> - 이 방식은 작업 수에 맞추어 스레드 수가 변하기 때문에, 작업의 처리 속도도 빠르고, CPU, 메모리를 매우 유연하게 사용할 수 있다는 장점이 있다.
>   - 하지만 가장 큰 단점이 되기도 한다.

- **상황 1 - 점진적인 사용자 확대**
  - 캐시 스레드 전략을 사용하면 이런 경우는 크게 문제가 되지 않는다.
  - 물론 CPU, 메모리 자원은 한계가 있기 때문에 적절한 시점에 시스템을 증설해야 한다.
  - 그렇지 않으면 CPU, 메모리 같은 시스템 자원을 너무 많이 사용하면서 시스템이 다운될 수 있다.


- **상황 2 - 갑작스러운 요청 증가**
  - CPU, 메모리 사용량을 확인해 보니, CPU 사용량이 100%이고, 메모리 사용량도 지나치게 높아져 있다.
  - 스레드 수를 확인해 보니 스레드가 수 천 개 실행되고 있었다.
    - 너무 많은 스레드가 작업을 처리하면서 시스템 전체가 느려지는 현상이 발생한다.
  - 시스템은 너무 많은 스레드에 잠식당해서 거의 다운된다. 메모리도 거의 다 사용되어 버린다.
  - 시스템이 멈추는 장애가 발생한다.

---

#### 📌 정리
- `고정 스레드 풀 전략`은 서버 자원은 여유가 있는데, 사용자만 점점 느려지는 문제가 발생할 수 있다.
- 반면에 `캐시 스레드 풀 전략`은 서버의 자원을 최대한 사용하지만, 서버가 감당할 수 있는 임계점을 넘는 순간 시스템이 다운될 수 있다.

---

### 📚 사용자 정의 풀 전략
1. 상황 - 점진적인 사용자 확대
2. 상황 - 갑작스러운 요청 증가
    - 다음과 같이 세분화된 전략을 사용하면 상황 1, 상황 2를 모두 어느 정도 대응할 수 있다.
        1. 일반: 일반적인 상황에는 CPU, 메모리 자원을 예측할 수 있도록 고정 크기의 스레드로 서비스를 안정적으로 운영한다.
        2. 긴급: 사용자의 요청이 갑자기 증가하면 긴급하게 스레드를 추가로 투입해서 작업을 빠르게 처리한다.
        3. 거절: 사용자의 요청이 폭증해서 긴급 대응도 어렵다면 사용자의 요청을 거절한다.

- 세분화 전략은 다음과 같이 적용할 수 있다.
```java
ExecutorService es = new ThreadPoolExecutor(100, 200, 60, TimeUnit.SECONDS, new ArrayBlockingQueue<>(1000));
```
- 100개의 기본 스레드를 사용한다.
- 추가로 긴급 대응 가능한 긴급 스레드 100개를 사용한다. 긴급 스레드는 60초의 생존주기를 가진다.
- 1000개의 작업이 큐에 대기할 수 있다.
- **대용량 트래픽, 큐를 어떻게 처리할 지에 대한 예시 대안!**

> 🔍 결과
> - 작업이 1100개가 동시에 들어오면 기본 스레드는 100개를 사용하고 나머지는 큐에 보관한다.
> - 작업이 1200개가 동시에 들어오면 기본 스레드 100개 이후 큐 사이즈도 꽉 차기 때문에 초과 스레드 100개도 추가로 생성되어 작업 시간이 2배 빨라진다.
>   - 대신에 CPU, 메모리 사용을 더 하기 때문에 이런 부분을 감안해서 최대 스레드 수를 정해야 한다.
> - 만약 작업 수가 1200개가 넘어가면 넘어간 작업은 예외가 발생하고 요청을 거절한다.

> 🤔 실무에서 자주 하는 실수
> - 기본 스레드 100, 최대 스레드 200, 큐 사이즈 무한대로 설정하면 긴급 상황에서의 최대 스레드 수를 늘릴 수 없게 된다.
> - 긴급 상황에 대비할 것이라면 큐 사이즈를 정해두자❗.

---

## ✅ Executor 예외 정책
- 생산자 소비자 문제를 실무에서 사용할 때는, 결국 소비자가 처리할 수 없을 정도로 생산 요청이 가득 차면 어떻게 할지를 정해야 한다.
- 개발자가 인지할 수 있게 로그도 남겨야 하고, 사용자에게 현재 시스템에 문제가 있다고 알리는 것도 필요하다.
- 이런 것을 위해 예외 정책이 필요하다.

### 📚 ThreadPoolExecutor는 작업을 거절하는 다양한 정책을 제공한다.
1. AbortPolicy: 새로운 작업을 제출할 때 RejectedExecutionException을 발생시킨다. 기본 정책이다.
2. DiscardPolicy: 새로운 작업을 조용히 버린다.
3. CallerRunsPolicy: 새로운 작업을 제출한 스레드가 대신해서 직접 작업을 실행한다.
4. 사용자 정의 (RejectedExecutionHandler): 개발자가 직접 정의한 거절 정책을 사용할 수 있다.

- 참고로 ThreadPoolExecutor를 shutdown()하면 이후에 요청하는 작업을 거절하는데, 이때도 같은 정책이 적용된다.

---

#### 🔍 1. AbortPolicy
- ThreadPoolExecutor 생성자 마지막에 new ThreadPoolExecutor.AbortPolicy()를 제공하면 된다.
- 참고로 이것이 기본 정책이기 때문에 생략해도 된다.
- RejectedExecutionException 예외를 잡아서 작업을 포기하거나, 사용자에게 알리거나, 다시 시도하면 된다.
- 이렇게 예외를 잡아서 필요한 코드를 직접 구현해도 되고, 아니면 다른 정책들을 사용해도 된다.

---

#### 🔍 2. DiscardPolicy
- 거절된 작업을 무시하고 아무런 예외도 발생시키지 않는다.

---

#### 🔍 3. CallerRunsPolicy
- 호출한 스레드가 직접 작업을 수행하게 한다. 이로 인해 새로운 작업을 제출하는 스레드의 속도가 느려질 수 있다.
```java
ExecutorService es = new ThreadPoolExecutor(1, 1, 0, TimeUnit.SECONDS, 
        new SynchronousQueue<>(), new ThreadPoolExecutor.CallerRunsPolicy()); 
```
- 작업 2개가 들어왔을 때, 하나는 스레드 풀에 있는 스레드가 수행하지만, 다른 하나는 스레드도 큐도 작업을 수행할 수 없기 때문에 이 예외 정책에서는 요청한 스레드에게 작업을 수행하게 맡긴다.
  - 메인 스레드가 요청했다면, 메인 스레드가 작업 2를 수행하게 된다.

> ❗ 특징
> - 이 정책의 특징은 생산자 스레드가 소비자 대신 일을 수행하는 것도 있지만, 생산자 스레드가 대신 일을 수행하는 덕분에 작업의 생산 자체가 느려진다는 점이다.
> - 덕분에 작업의 생산 속도가 너무 빠르다면, 생산 속도를 조절할 수 있다.

---

#### 🔍 사용자 정의
- 사용자는 RejectedExecutionHandler 인터페이스를 구현하여 자신만의 거절 처리 전략을 정의할 수 있다.
- 이를 통해 요구사항에 맞는 작업 거절 방식을 설정할 수 있다.

```java
ExecutorService es = new ThreadPoolExecutor(1, 1, 0, TimeUnit.SECONDS,
        new SynchronousQueue<>(), new MyRejectedExecutionHandler());

    static class MyRejectedExecutionHandler implements RejectedExecutionHandler {
        @Overrite
        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
            // 직접 구현하기, 예시로 거절한 작업 수 등등
        }
    }
```

---

## 📌 총정리
1. **실무 전략 선택**
    - 고정 스레드 풀 전략: 트래픽이 일정하고, 시스템 안정성이 가장 중요.
    - 캐시 스레드 풀 전략: 일반적인 성장하는 서비스.
    - 사용자 정의 풀 전략: 다양한 상황에 대응.

- 가장 좋은 최적화는 최적화하지 않은 것이다.
- 중요한 것은 예측 불가능한 너무 먼 미래보다는 현재 상황에 맞는 최적화가 필요하다는 점이다.
- 시스템 상황을 잘 모니터링하다가, 최적화가 필요한 부분들이 발생하면, 그때 필요한 부분들을 개선하는 것이다.
- 백엔드 서버 개발자라면 시스템의 자원을 적절하게 활용하되, 최악의 경우 거절을 통해 시스템이 다운되지 않도록 해야 한다.

---