# 📚 Chapter 4: 스레드 제어와 생명 주기2

> 📌 공부 날짜: 2025/04/17
> - `JAVA `- 고급1편
> - `Reference`: 인프런 - 김영한의 실전 자바

---

## ✅ 인터럽트
- 인터럽트를 사용하면, WAITING, TIMED_WAITING 같은 대기 상태의 스레드를 직접 깨워서 작동하는 Runnable 상태로 만들 수 있다.
- 특정 스레드의 인스턴스에 interrupt() 메서드를 호출하면, 해당 스레드에 인터럽트가 발생.
  - 이때 인터럽트를 받은 스레드는 대기 상태에서 깨어나 Runnable 상태가 되고, 코드를 정상 흐름으로 바꾼다.
  - 이때 `InterruptedException`을 `catch`로 잡아서 정상 흐름으로 변경하면 된다.
- **참고로 interrupt()를 호출했다고 해서 즉각 InterruptedException이 발생하는 것은 아니다. 오직 sleep() 처럼 InterruptedException을 던지는 메서드를 호출하거나 또는 호출 중일 때 예외가 발생한다.**

---

### 📚 isInterrupted()
- isInterrupted() 메서드는 인터럽트의 상태를 변경하지 않는다. 단순히 인터럽트의 상태를 확인.

> - 자바에서 인터럽트 예외가 한 번 발생하면, 스레드의 인터럽트 상태를 다시 정상(false)으로 돌려야 하는 것은 뒤에 대기 상태가 있으면 예외 처리를 하기 때문에 원했던 작업을 마무리 하지 못 할 수도 있다.
> - 스레드의 인터럽트 상태를 정상으로 돌리지 않으면 이후에도 계속 인터럽트가 발생하게 된다.
> - 인터럽트의 목적을 달성하면 인터럽트 상태를 다시 정상으로 돌려두어야 한다.

---

### 📚 Thread.interrupted()
- 스레드의 인터럽트를 단순히 확인하는 용도면 isInterrupted()를 사용하면 된다.
  - 하지만 직접 체크해서 사용해야 할 경우에는 Thread.Interrupted()를 사용해야 한다.

> 🔍 메서드 작동
> - 스레드가 인터럽트 상태라면 true를 반환하고, 해당 스레드의 인터럽트 상태를 false로 변경한다.
> - 스레드가 인터럽트 상태가 아니라면 false를 반환하고, 인터럽트 상태는 변경하지 않는다.

- 꼭 인터럽트 상태를 false로 변경을 해야만 하는 것은 아니다. 예를 들어 너무 긴급한 상황이어서 자원 정리도 하지 않고, 최대한 빨리 스레드를 종료해야 한다면 해당 스레드를 다시 인터럽트 상태로 변경하는 것도 방법이다.

---

### 📚 yield - 양보하기
- 어떤 스레드를 얼마나 실행할지는 운영체제가 스케줄링을 통해 결정된다.
  - 그런데 특정 스레드가 크게 바쁘지 않은 상황이어서 다른 스레드에 CPU 실행 기회를 영보하고 싶을 수 있다.
  - 이렇게 양보하면 스케줄링 큐에 대기 중인 다른 스레드가 CPU 실행 기회를 더 빨리 얻을 수 있다.

> 🔍 자바의 스레드가 RUNNABLE 상태일 때, 운영체제의 스케줄링은 다음과 같은 상태를 가질 수 있다.
>   - 실행 상태(Running): 스레드가 CPU에서 실제로 실행 중이다.
>   - 실행 대기 상태(Ready): 스레드가 실행될 준비가 되었지만, CPU가 바빠서 스케줄링 큐에서 대기 중이다.

- yield의 작동
  - Thread.yield() 메서드는 현재 실행 중인 스레드가 자발적으로 CPU를 양보하여 다른 스레드가 실행될 수 있도록 한다.
  - yield() 메서드를 호출한 스레드는 RUNNABLE 상태를 유지하면서 CPU를 양보한다.
    - 즉, 이 스레드는 다시 스케줄링 큐에 들어가면서 다른 스레드에게 CPU 사용 기회를 넘긴다.

> 🔍 참고
> - yield()는 운영체제의 스케줄러에게 단지 힌트를 제공할 뿐, 강제적인 실행 순서를 지정하지 않는다.
>   - 그리고 반드시 다른 스레드가 실행되는 것도 아니다.
> - 최근에는 10코어 이상의 CPU도 많기 때문에 스레드 10개 정도만 만들어서 실행하면 양보가 크게 의미 없어진다.
> - CPU 코어 수 이상의 스레드를 만들어야 양보하는 상황을 확인할 수 있다.

---