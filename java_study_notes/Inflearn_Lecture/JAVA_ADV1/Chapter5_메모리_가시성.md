# 📚 Chapter 5: 메모리 가시성

> 📌 공부 날짜: 2025/04/18
> - `JAVA `- 고급1편
> - `Reference`: 인프런 - 김영한의 실전 자바

---

## ✅ 메모리 가시성

### 📚 실제 메모리 접근 방식
- CPU 처리 성능을 개선하기 위해 중간에 캐시 메모리를 사용한다.
- 메인 메모리는 CPU 입장에서 보면 거리가 멀고, 속도도 상대적으로 느리다.
- CPU 연산은 매우 빠르기 때문에 CPU 연산의 빠른 성능을 따라가려면, CPU 가까이에 매우 빠른 메모리가 필요한데, 이것이 바로 캐시 메모리다.
- CPU의 대부분은 코어 단위로 캐시 메모리를 가진다.

> 🤔 예시)
> - while문에 조건이 boolean 타입인 runFlag가 true로 선언되어 반복적으로 수행되고 있다.
> - 이때 main 스레드와 work 스레드가 있는데 둘 다 while문이 있는 클래스에 접근하고 있다.
> - main 스레드에서 runFlag의 값을 false로 변경하였을 때 main 스레드의 runFlag false로 변경되었고, work 스레드 또한 runFlag의 값이 바뀔 것이라고 예상된다.
> - **하지만 work 스레드에서 실행한 while문은 종료되지 않았다.**
> - 🔍 그 이유는 위의 설명과 같이 메인 메모리에 바로 접근하는 것이 아닌 캐시 메모리부터 먼저 접근 후 메인 메모리에 반영하기 때문에 main 스레드 값이 바뀌더라도 work 스레드의 값이 바로 바뀌지 않게 되는 것이다.
> - ❓ 그러면 캐시 메모리를 메인 메모리에 반영하거나, 메인 메모리의 변경 내역을 캐시 메모리에 다시 불러오는 것은 언제 발생할까??
>   - 이 부분은 CPU 설계 방식과 실행 환경에 따라 다를 수 있다.
>   - 즉시 반영될 수도 있고, 몇 밀리초 후, 몇 초 후, 평생 반영이 안 될 수도 있다.
>   - 주로 컨텍스트 스위칭이 될 때, 캐시 메모리도 함께 갱신되는데, 이것 또한 보장되는 건 아니다.
>   - Thread.sleep(), 콘솔 출력 등을 할 때 스레드가 잠시 쉬는데, 이때 컨텍스트 스위칭이 발생되면서 주로 갱신된다.

---

### 📚 메모리 가시성 (Memory Visibility)
- 멀티스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에 언제 보이는지에 대한 문제를 `메모리 가시성`이라 한다.
- 이름 그대로 메모리 변경한 값이 보이는 가, 보이지 않는 가의 문제이다.

> 🔍 참고
> - 캐시 메모리를 사용하면 CPU 처리 성능은 개선할 수 있다.
> - 하지만 때로는 이런 성능 향상보다는, 여러 스레드에서 같은 시점에 정확히 같은 데이터를 보는 것이 중요할 수도 있다.
> - ❗ 해결 방안은 아주 단순하다. 성능을 약간 포기하는 대신, 값을 읽을 때, 값을 쓸 때 모두 메인 메모리에 직접 접근하면 된다.
> - 자바에서는 `volatile` 이라는 키워드로 이런 기능을 제공한다.
>   - ex) volatile boolean runFlag = true;
> - 이렇게 하면 runFlag에 대해서는 캐시 메모리를 사용하지 않고, 값을 읽거나 쓸 때 항상 메인 메모리에 직접 접근한다.

- **여러 스레드에서 같은 값을 읽거나 쓸 때 `volatile` 키워드를 사용하면 되지만, 성능이 느려지는 단점이 있어, 꼭 필요한 곳에서만 사용하는 것이 좋다.**

---

### 📚 자바 메모리 모델
1. 메모리 가시성 (Memory Visibility)

2. Java Memory Model
   - JVM은 자바 프로그램이 어떻게 메모리에 접근하고 수정할 수 있는지를 규정하며, 특히 멀티스레드 프로그래밍에서 스레드 간의 상호작용을 정의한다.
   - 핵심은 여러 스레드들의 작업 순서를 보장하는 happens-before 관계에 대한 정의다.

3. happens-before
  - happens-before 관계는 자바 메모리 모델에서 스레드 간의 작업 순서를 정의하는 개념이다.
  - 만약 A 작업이 B 작업보다 happens-before 관계에 있다면, A 작업에서의 모든 메모리 변경사항은 B 작업에서 볼 수 있다.
  - 즉, A 작업에서 변경된 내용은 B 작업이 시작되기 전에 모두 메모리에 반영된다.

> 🔍 happens-before 관계는 이름 그대로 한 동작이 다른 동작보다 먼저 발생함을 보장한다.
> - 스레드 간의 메모리 가시성을 보장하는 규칙이다.
> - 관계가 성립되면, 한 스레드의 작업을 다른 스레드에서 볼 수 있다.
> - 즉, 한 스레드에서 수행한 작업을 다른 스레드가 참조할 때 최신 상태가 보장되는 것이다.

---

## ✅ 정리
- **volatile 키워드 또는 스레드 동기화 기법(synchronized, ReentrantLock)을 사용하면 가시성의 문제가 발생하지 않는다.**

---