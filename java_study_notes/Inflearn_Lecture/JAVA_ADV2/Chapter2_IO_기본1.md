# 📚 Chapter 2: IO 기본 1

> 📌 공부 날짜: 2025/05/15
> - `JAVA `- 고급 2편
> - `Reference`: 인프런 - 김영한의 실전 자바

---

## ✅ 스트림 시작 1
- 자바 프로세스가 가지고 있는 데이터를 밖으로 보내려면 출력 스트림을 사용하면 되고,
 반대로 외부 데이터를 자바 프로세스 안으로 가져오려면 입력 스트림을 사용하면 된다.

#### 🔍 new FileOutputStream("temp/hello.dat")
- 파일에 데이터를 출력하는 스트림이다.
- 파일이 없으면 파일을 자동으로 만들고, 데이터를 해당 파일에 저장한다.
- 폴더를 만들지는 않기 때문에 폴더는 미리 만들어 두어야 한다.

#### 🔍 write()
- byte 단위로 값을 출력한다.

#### 🔍 new FileInputStream("temp/hello.dat")
- 파일에서 데이터를 읽어오는 스트림이다.

#### 🔍read()
- 파일에서 데이터를 byte 단위로 하나씩 읽어온다.
- 파일의 끝에 도달해서 더는 읽을 내용이 없다면 -1을 반환한다.
  - 파일의 끝(EOF, End Of File)

#### 🔍close()
- 파일에 접근하는 것은 자바 입장에서 외부 자원을 사용하는 것이다.
- 자바에서 내부 객체는 자동으로 GC가 되지만 외부 자원은 사용 후 반드시 닫아주어야 한다.

> 🔍 참고: 파일 append 옵션
> - `FileOutputStream`의 생성자에는 `append`라는 옵션이 있다.
> - `new FileOutputStream("temp/hello.dat", true);`
>   - `true`: 기존 파일의 끝에 이어서 쓴다.
>   - `false`: 기존 파일의 데이터를 지우고 처음부터 다시 쓴다. (기본값)

---

## ✅ 스트림 시작 2
- byte()을 사용해서 데이터를 원하는 크기만큼 더 편리하게 저장하고 읽는 방법을 알아보자.

#### 🔍 write(byte[]) - 출력 스트림
- byte[]에 원하는 데이터를 담고 `write()`에 전달하면 해당 데이터를 한 번에 출력할 수 있다.

### 📚 입력 스트림
- `read(byte[], offset, length)`: byte[]을 미리 만들어 두고, 만들어 둔 byte[]에 한 번에 데이터를 읽어올 수 있다.
- `byte[]`: 데이터가 읽히는 버퍼
- `offset`: 데이터 기록되는 byte[]의 인덱스 시작 위치.
- `length`: 읽어올 byte의 최대 길이
- `반환 값`: 버퍼에 읽을 총 바이트 수, 스트림의 끝에 도달하여 더 이상 데이터가 없는 경우 -1을 반환.
- **참고로 offset, length를 생략할 시 `offset`은 0, `length`는  byte[].length가 된다.**

#### 🔍 모든 byte 한 번에 읽기
```java
// ex)
byte[] readBytes = fis.readAllBytes();
```
- readAllBytes()를 사용하면 스트림이 끝날 때까지 모든 데이터를 한 번에 읽어올 수 있다.

#### 🔍 부분으로 나누어 읽기 vs 전체 읽기
1. read(bytes[], offset, length)
  - 스트림의 내용을 부분적으로 읽거나, 읽은 내용을 처리하면서 스트림을 계속해서 읽어야 할 경우에 적합하다.
  - 메모리 사용량을 제어할 수 있다.
  - 예시) 대용량 파일을 처리할 때, 한 번에 메모리에 로드하기보다는 이 메서드를 사용하여 파일을 조각조각 읽어 들일 수 있다.

2. readAllBytes()
  - 한 번의 호출로 모든 데이터를 읽을 수 있어 편리하다.
  - 작은 파일이나 메모리에 모든 내용을 올려서 처리해야 하는 경우에 적합하다.
  - 메모리 사용량을 제어할 수 없다.
  - 큰 파일의 경우 `OutOfMemoryError`가 발생할 수 있다.

---

### 📚 InputStream, OutputStream
- 현대의 컴퓨터는 대부분 byte 단위로 데이터를 주고받는다.
- 이렇게 데이터를 주고받는 것을 `Input/Output(I/O)`라 한다.
- 자바 내부에 있는 데이터를 외부에 있는 파일에 저장하거나, 네트워크를 통해 전송하거나 콘솔에 출력할 때 모두 byte 단위로 데이터를 주고받는다.
- 만약 파일, 네트워크, 콘솔 각각 데이터를 주고받는 방식이 다르다면 상당히 불편할 것이다.
  - 이런 문제를 해결하기 위해 자바는 `InputStream, OutputStream`이라는 기본 추상 클래스를 제공한다.
- 스트림을 사용하면 파일을 사용하든, 소켓을 통해 네트워크를 사용하든 모두 일관된 방식으로 데이터를 주고받을 수 있다.

---

### 📚 메모리 스트림
- `ByteArrayOutputStream, ByteArrayInputStream`을 사용하면 메모리에 스트림을 쓰고 읽을 수 있다.
- 이 클래스들은 `OutputStream, InputStream`을 상속받았기 때문에 부모의 기능올 모두 사용할 수 있다.
- 참고로 메모리에 어떤 데이터를 저장하고 읽을 때는 컬렉션이나 배열을 사용하면 되기 때문에, 이 기능을 잘 사용하지 않는다.
- 주로 스트림을 간단하게 테스트하거나 스트림의 데이터를 확인하는 용도로 사용한다.

---

### 📚 콘솔 스트림
- 우리가 자주 사용했던 `System.out`이 사실은 `PrintStream`이다.
  - 이 스트림은 `OutputStream`을 상속받는다.
- 이 스트림은 자바가 시작될 때 자동으로 만들어진다. 따라서 우리가 직접 생성하지 않는다.

---

## 📌 정리
- `InputStream`과 `OutputStream`이 다양한 스트림들을 추상화하고, 기본 기능에 대한 표준을 잡아둔 덕분에 개발자는 편리하게 입출력 작업을 수행할 수 있다.
- 이런 추상화의 장점은 다음과 같다.

#### 1. 일관성
- 모든 종류의 입출력 작업에 대해 동일한 인터페이스(여기서는 부모의 메서드)를 사용할 수 있어, 코드의 일관성이 유지된다.

#### 2. 유연성
- 실제 데이터 소스나 목적지가 무엇인지에 관계없이 동일한 방식으로 코드를 작성할 수 있다.
- 예를 들어, 파일, 네트워크, 메모리 등 다양한 소스에 대해 동일한 메서드를 사용할 수 있다.

#### 3. 확장성
- 새로운 유형의 입출력 스트림을 쉽게 추가할 수 있다.

#### 4. 재사용성
- 다양한 스트림 클래스들을 조합하여 복잡한 입출력 작업을 수행할 수 있다.
- 예를 들어 `BufferedInputStream`을 사용하여 성능을 향상시키거나, `DataInputStream`을 사용하여 기본 데이터 타입을 쉽게 읽을 수 있다.

#### 5. 에러 처리
- 표준화된 예외 처리 메커니즘을 통해 일관된 방식으로 오류를 처리할 수 있다.

---

## ✅ 파일 입출력과 성능 최적화 1
```java
// ex)
for (int i = 0; i < FILE_SIZE; i++) {
    fos.write(i);
}
fos.close();
```
- 가장 단순한 `FileOutputStream`의 `write()`를 사용해서 1byte씩 파일을 저장했다.
- 그리고 10MB 파일을 만드는 데 걸리는 시간을 확인해 본다.

```java
// ex)
while ((data = fis.read()) != -1) {
    fileSize++;
}
fis.close();
```
- `FileInputStream`의 `read()`를 사용해서 앞서 만든 파일에서 1byte씩 데이터를 읽는다.

### 📌 정리
- 10MB 파일 하나를 쓰는데 14초, 읽는데 5초라는 매우 오랜 시간이 걸렸다.
- 오래 걸린 이유는 자바에 1byte씩 디스크에 데이터를 전달했기 때문이다.

> 🤔 더 자세히 설명하면 다음 2가지 이유로 느려진다.
> - 1. write()나 read()를 호출할 때마다 OS의 시스템 콜을 통해 파일을 읽거나 쓰는 명령어를 전달한다.
>   - 이러한 시스템 콜은 상대적으로 무거운 작업이다.
> - 2. HDD, SDD 같은 장치들도 하나의 데이터를 읽고 쓸 때마다 필요한 시간이 있다.
>   - HDD의 경우 더욱 느린데, 물리적으로 디스크의 회전이 필요하다.

#### 🔍 참고
- 자바에서 1byte씩 `write()`나 `read()`를 호출할 때마다 운영 체제로의 시스템 콜이 발생하고, 이 시스템 콜 자체가 상당한 오버헤드를 유발한다.
- 운영체제와 하드웨어가 어느 정도 최적화를 제공하더라도, 자주 발생하는 시스템 콜로 인한 성능 저하는 피할 수 없다.
  - 결국 자바에서 `read(), write()` 호출 횟수를 줄여서 시스템 콜 횟수도 줄여야 한다❗.

---

## 파일 입출력과 성능 최적화 2 - 버퍼 활용
- 1byte씩 데이터를 하나씩 전달하는 것이 아니라 byte[]을 통해 배열에 담아서 한 번에 여러 byte를 전달해 보자.

```java
// ex)
byte[] buffer = new byte[BUFFER_SIZE];
for (int i = 0; i < FILE_SIZE; i++) {
    buffer[bufferIndex++] = 1;
    if (bufferIndex == BUFFER_SIZE) { // 버퍼가 가득차면 쓰고, 버퍼를 비운다.
        fos.write(buffer);
        bufferIndex = 0;
    }
}
if (bufferIndex > 0) { // 버퍼에 남은 부분 쓰기
    fos.write(buffer, 0, bufferIndex);    
}
fos.close();
```

- 데이터를 먼저 `buffer`라는 byte[]에 담아둔다.
  - 이렇게 데이터를 모아서 전달하거나 모아서 전달받는 용도로 사용하는 것을 버퍼라 한다.
- 여기서는 `BUFFER_SIZE`만큼 데이터를 모아서 `write()`를 호출한다.
  - 예를 들어, `BUFFER_SIZE`가 10이라면 10만큼 모이면 `write()`를 호출해서 10byte를 한 번에 스트림에 전달한다.

### 📚 버퍼 크기에 따른 쓰기 성능
- 많은 데이터를 한 번에 전달하면 성능을 최적화할 수 있다. 이렇게 되면 시스템 콜도 줄어들고, HDD, SDD 같은 장치들의 작동 횟수도 줄어든다.
- 그런데 버퍼의 크기가 커진다고 해서 속도가 계속 줄어들지는 않는다.
- 왜냐하면 디스크나 파일 시스템에서 데이터를 읽고 쓰는 기본 단위가 보통 4KB 또는 8KB이기 때문이다.
- **결국 버퍼에 많은 데이터를 담아서 보내도 디스크나 파일 시스템에서 해당 단위로 나누어 저장하기 때문에 효율에는 한계가 있다.**
  - 따라서 버퍼의 크기는 보통 **4KB, 8KB** 정도로 잡는 것이 효율적이다.
- **버퍼를 사용하면 큰 성능 향상이 있다. 하지만 직접 버퍼를 만들고 관리해야 하는 번거로운 단점이 있다.**

---

## ✅ 파일 입출력과 성능 최적화 3 - Buffered 스트림 쓰기
- `BufferedOutputStream`은 버퍼 기능을 내부에서 대신 처리해 준다. 따라서 단순한 코드를 유지하면서 버퍼를 사용하는 이점도 함께 누릴 수 있다.
```java
// ex)
BufferedOutputStream bos = new BufferedOutputStream(fos, BUFFER_SIZE);
```
- 내부에서 단순히 버퍼 기능만 제공한다. 따라서 반드시 대상 OutputStream이 있어야 한다.
- 추가로 사용할 버퍼의 크기도 함께 전달할 수 있다.

#### 🔍 flush()
- 버퍼가 다 차지 않아도 버퍼에 남아있는 데이터를 전달하려면 `flush()`라는 메서드를 호출하면 된다.

#### 🔍 close()
- 만약 버퍼에 데이터가 남아있는 상태로 close()를 호출하면 어떻게 될까?
- `BufferedOutputStream`을 `close()`로 닫으면 먼저 내부에서 `flush()`를 호출한다.
- 따라서 `close()`를 호출해도 남은 데이터를 안전하게 저장할 수 있다.
- 버퍼가 비워지고 나면 `close()`로 `BufferedOutputStream`의 자원을 정리한다.
- 그러고 나서 다음 연결된 스트림의 `close()`를 호출한다. 여기서는 `fos -> FileOutputStream`의 자원이 정리된다.
- 여기서 핵심은 `close()`를 호출하면 `close()`가 연쇄적으로 호출된다는 점이다.
  - 따라서 마지막에 연결한 `BufferedOutputStream`만 닫아주면 된다.

#### 🔍 기본 스트림, 보조 스트림
- `FileOutputStream`과 같이 단독으로 사용할 수 있는 스트림을 `기본 스트림`이라 한다.
- `BufferedOutputStream`과 같이 단독으로 사용할 수 없고, 보조 기능을 제공하는 스트림을 `보조 스트림`이라 한다.

### 📌 정리
- `BufferedOutputStream`도 `OutputStream`의 자식이기 때문에 `OutputStream`의 기능을 그대로 사용할 수 있다.
  - `write()`의 경우 먼저 버퍼에 쌓이도록 재정의 된다.
- 버퍼의 크기만큼 데이터를 모아서 전달하기 때문에 빠른 속도로 데이터를 처리할 수 있다.
- 읽기도 마찬가지다.

---

## 🤔 버퍼를 직접 다루는 것보다 BufferedXxx의 성능이 떨어지는 이유
- 동기화 때문
- `BufferedXxx` 클래스는 모두 동기화 처리가 되어있다.

### 📚 BufferedXxx 클래스의 특징
- 멀티 스레드에 안전하지만 락을 걸고 푸는 동기화 코드로 인해 성능이 약간 저하될 수 있다.
- 일반적인 상황이라면 이 정도 성능은 크게 문제가 되지 않기 때문에 싱글 스레드여도 BufferedXxx를 사용하면 괜찮다.
- 물론 매우 큰 데이터를 다루어야 하고, 성능 최적화가 중요하다면 직접 버퍼를 다루는 방법을 고려하자.
- 동기화 락이 없는 클래스는 없기 때문에, 꼭 필요한 상황이라면 `BufferedXxx`를 참고해서 동기화 락 코드를 제거한 클래스를 직접 만들어서 사용하면 된다.

---

## 🔍 파일 입출력과 성능 최적화 - 한 번에 쓰기
- 파일의 크기가 크지 않다면 간단하게 한 번에 쓰고 읽는 것도 좋은 방법이다.
- 이 방법은 성능은 가장 좋지만, 결과적으로 메모리를 한 번에 많이 사용하기 때문에 파일의 크기가 작아야 한다.
- 버퍼 사이즈를 파일 사이즈와 동일하게.
  - ex) new byte[FILE_SIZE]

---

## 📌 마무리
- 파일의 크기가 크지 않아서, 메모리 사용에 큰 영향을 주지 않는다면 쉽고 빠르게 한 번에 처리하자.
- 성능이 중요하고 큰 파일을 나누어 처리해야 한다면, 버퍼를 직접 다루자.
- 성능이 크게 중요하지 않고, 버퍼 기능이 필요하면 `BufferedXxx`를 사용하자.
  - `BufferedXxx`는 동기화 코드가 들어있어서 스레드에 안전하지만, 약간의 성능 저하가 있다.

---
