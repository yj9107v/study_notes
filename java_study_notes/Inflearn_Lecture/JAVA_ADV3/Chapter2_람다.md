# 📚 Chapter 2: 람다

> 📌 공부 날짜: 2025/09/22
> - `JAVA `- 고급 3편
> - `References`: [인프런 - 김영한의 실전 자바](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B3%A0%EA%B8%89-3)

---

## ✅ 람다 정의
- 자바 8부터 도입된 람다는 자바에서 함수형 프로그래밍을 지원하기 위한 핵심 기능이다.

> **용어 - 람다 vs 람다식(Lambda Expression)**
> - **람다**: 익명 함수를 지칭하는 일반적인 용어다. 개념이라는 것
> - **람다식**: (매개변수) -> {본문} 형태로 람다를 구현하는 구체적인 문법 표현을 지칭
> 
> 쉽게 이야기해서 람다는 개념을, 람다식은 자바에서 개념을 구현하는 구체적인 문법을 의미한다.
> 람다가 넓은 의미이고, 또 실무에서 두 용어를 구분해서 사용하지는 않기 때문에 대부분 간결하게 `람다`라고 한다.

**람다는 표현이 간결하다.**
```java
// 익명 클래스
Procedure procedure = new Procedure() {
    @Override
    public void run() {
      System.out.println("hello! lambda");
    }
}
```

```java
// 람다
Procedure procedure = () -> System.out.println("hello! lambda");
```

#### 📌 정리
- 람다를 사용하면 익명 클래스 사용의 보일러플레이트 코드를 크게 줄이고, 간결한 코드로 생산성과 가독성을 높일 수 있다.
- 대부부느이 익명 클래스는 람다로 대체할 수 있다.
  - 참고로 람다가 익명 클래스를 완전히 대체할 수 있는 것은 아니다.
- 람다를 사용할 때 `new` 키워드를 사용하지 않지만, 람다도 익명 클래스처럼 인스턴스가 생성된다.
- 지금은 람다를 익명 클래스의 구현을 간단히 표현할 수 있는 **문법 설탕(Syntactic sugar, 코드를 간결하게 만드는 문법적 편의)** 역할 정도로 생각하자.

---

## ✅ 함수형 인터페이스
- **함수형 인터페이스**는 정확히 하나의 추상 메서드를 가지는 인터페이스를 말한다.
- 람다는 추상 메서드가 하나인 `함수형 인터페이스`에만 할당할 수 있다.
- 단일 추상 메서드를 줄여서 `SAM(Single Abstract Method)`이라 한다.
- 참고로 람다는 클래스, 추상 클래스에는 할당할 수 없다. 오직 단일 추상 메서드를 가지는 인터페이스에만 할당할 수 있다.

**여러 추상 메서드**
```java
public interface NotSamInterface {
    void run();
    void go();
}
```
- 인터페이스의 메서드 앞에는 `abstarck`(추상)이 생략되어 있다.
- 여기에는 두 개의 추상 메서드가 선언되어 있어 단일 추상 메서드(SAM)가 아니다.
  - 이 인터페이스에는 람다를 할당할 수 없다.

**단일 추상 메서드**
```java
public interface SamInterface {
    void run();
}
```
- 여기에는 한 개의 추상 메서드만 선언되어 있다.
  - 단일 추상 메서드(SAM)이다. 이 인터페이스에는 람다를 할당할 수 있다.

---

### 📚 @FunctionalInterface
단 하나의 추상 메서드만을 포함한다는 것을 어떻게 보장할 수 있을까?

`@FunctionalInterface` 애노테이션을 붙여주면 된다. 이 애노테이션이 있으면 단 하나의 추상 메서드가 아니면 컴파일 단계에서 오류가 발생한다.
따라서 함수형 인터페이스임을 보장할 수 있다.

```java
@FunctionalInterface
public interface SamInterface {
    void run();
}
```
- 함수형 인터페이스가 아니라면 컴파일 오류 메시지를 나타내줌.

따라서 람다를 사용할 함수형 인터페이스라면 `@FunctionalInterface`를 필수로 추가하는 것을 권장한다.

---

## ✅ 람다와 시그니처
람다를 함수형 인터페이스에 할당할 때는 메서드의 형태를 정의하는 요소인 메서드 시그니처가 일치해야 한다.
메서드 시그니처의 주요 구성 요소는 다음과 같다.
1. 메서드 이름
2. 매개변수의 수와 타입(순서 포함) 
3. 반환 타입

람다는 익명 함수이므로 시그니처에서 이름은 제외하고, **매개변수, 반환 타입이 함수형 인터페이스에 선언한 메서드와 맞아야 한다.**

---

## ✅ 람다와 생략
람다는 간결한 코드 작성을 위해 다양한 문법 생략을 지원한다.

```java
public class LambdaSimple1 {
  public static void main(String[] args) {
    MyFunction function1 = (int a, int b) -> {
        return a + b;
    };

    // 단일 표현식인 경우 중괄호와 리턴 생략 가능
    MyFunction function2 = (int a, int b) -> a + b;
    
    // 단일 표현식이 아닐 경우 중괄호와 리턴 필수
    MyFunction function3 = (int a, int b) -> {
        System.out.println("람다 실행");
        return a + b;
    };

    // 매개변수, 반환 값이 있는 경우
    MyFunction function4 = (a, b) -> a + b;

    // 매개변수, 반환 값이 없는 경우
    Procedure procedure = () -> System.out.println("hello! lambda");
    
    // 매개변수 1개, () 생략 가능
    MyCall call = value -> value * 2;
  }
}
```

#### 🔍 표현식(expression)이란?
- 하나의 값으로 평가되는 코드 조각을 의미한다.
- 표현식은 산술 논리 표현식, 메서드 호출, 객체 생성 등이 있다.
  - 예) `x + y`, `price * quantity`, `calculateTotal()`, `age >= 18`
- 표현식이 아닌 것은 제어문, 메서드 선언 같은 것이 있다.
  - 예) `if (condition) {}`

#### 🔍 람다 - 단일 표현식(single expression)인 경우
- 중괄호 `{}`와 `return` 키워드를 함께 생략할 수 있음
  - 표현식의 결과가 자동으로 반환 값이 됨
- 중괄호를 사용하는 경우에는 반드시 `return`문을 포함해야 한다.
- `retuen`문을 명시적으로 포함하는 경우 중괄호를 사용해야 함
- 반환 타입이 `void`인 경우 `return` 생략 가능

#### 🔍 타입 추론
- 매개변수에 해당하는 `(int a, int b)` 부분을 보면, 함수형 인터페이스인 `MyFunction`의 `apply()` 메서드를 보면 이미 `int a, int b`로 매개변수의 타입이 정의되어 있다.
- 따라서 이 정보를 사용하면 람다의 `(int a, int b)`에서 타입 정보를 생략할 수 있다.
- 자바 컴파일러는 람다가 사용되는 함수형 인터페이스의 메서드 타입을 기반으로 람다의 매개변수와 반환값의 타입을 추론한다.
  - 따라서 람다는 타입을 생략할 수 있다.
- 반환 타입은 문법적으로 명시할 수 없다. 대신에 컴파일러가 자동으로 추론하는 것

#### 🔍 매개변수의 괄호 생략
- 매개변수가 정확히 하나이면서, 타입을 생략하고, 이름만 있는 경우 소괄호 `()`를 생략할 수 있다.
- 매개변수가 없는 경우에는 `()`가 필수
- 매개변수가 둘 이상이어도 `()`가 필수

---
### 📌 정리
- **매개변수 타입**: 생략 가능하지만 필요하다면 명시적으로 작성 가능
- **반환 타입**: 문법적으로 명시할 수 없고, 식의 결과를 보고 컴파일러가 항상 추론한다.
- 람다는 보통 간략하게 사용되는 것을 권장한다.
  - 단일 표현식이면 중괄호와 리턴을 생략하자.
  - 타입 추론을 통해 매개변수의 타입을 생략하자. (컴파일러가 추론할 수 있다면, 생략하자)

---

## ✅ 람다의 전달
람다는 함수형 인터페이스를 통해 변수에 대입하거나, 메서드에 전달하거나 반환할 수 있다.


### 📚 람다를 변수에 대입하기
```java
MyFunction add = (a, b) -> a + b;
MyFunction cal = add;
```
람다도 인터페이스(함수형 인터페이스)를 사용하므로, 람다 인스턴스의 참조값을 변수에 전달할 수 있다.

변수에 참조값을 전달할 수 있으므로 다음과 같이 사용할 수 있다.
- 매개변수를 통해 메서드(함수)에 람다를 전달할 수 있다.(정확히는 람다 인스턴스의 참조값을 전달)
- 메서드가 람다를 반환할 수 있다. (정확히는 람다 인스턴스의 참조값을 반환)

---
### 📚 람다를 메서드(함수)에 전달하기
람다를 매개변수를 통해 메서드(함수)에 전달

```java
public class LambdaPassMain2 {

  public static void main(String[] args) {
    MyFunction add = (a, b) -> a + b;
    MyFunction sub = (a, b) -> a - b;
    
    // 변수를 통해 전달
    calculate(add);
    calculate(sub);
    
    // 람다를 직접 전달
    calculate((a, b) -> a + b);
    calculate((a, b) -> a - b);
  }
  
  static void calculate(Function function) {
      int a = 1;
      int b = 2;

      System.out.println(function.apply(a, b));
  }
}
```

---
### 📚 람다를 반환하기
```java
public class LambdaPassMain3 {

  public static void main(String[] args) {
    MyFunction add = getOperated("add");
    add.apply(1, 2); // 답: 3
    
    MyFunction sub = getOperated("sub");
    add.apply(1, 2); // 답: -1
    
    MyFunction xxx = getOperated("xxx");
    add.apply(1, 2); // 답: 0
  }
  
  static MyFunction getOperated(String operator) {
      switch (operator) {
        case "add":
            return (a, b) -> a + b;
        case "sub":
            return (a, b) -> a - b;
        default:
            return (a, b) -> 0;
      }
  }
}
```

---

## ✅ 고차 함수
### 📚 람다의 전달 정리
람다는 함수형 인터페이스를 구현한 익명 클래스 인스턴스와 같은 개념이다.
즉, 람다를 변수에 대입한다는 것은 **람다 인스턴스의 참조값을 대입**하는 것이고,
람다를 메서드(함수)의 매개변수나 반환값으로 넘긴다는 것 역시 **람다 인스턴스의 참조값을 전달, 반환**하는 것이다.

이런 방식으로 람다를 자유롭게 전달하거나 반환할 수 있기 때문에, 코드의 간결성과 유연성이 높아진다. 만약 익명 클래스를 작성하고 전달했다면 매우 번잡했을 것이다.

---
### 📚 고차 함수(Higher-Order Function)
고차 함수는 함수를 값처럼 다루는 함수를 뜻한다.

일반적으로 다음 두 가지 중 하나를 만족하면 고차 함수라 한다.
- 함수를 인자로 받는 함수(메서드)
- 함수를 반환하는 함수(메서드)

즉, 매개변수나 반환값에 함수(또는 람다)를 활용하는 함수가 고차 함수에 해당

#### 🔍 용어 - 고차 함수
**고차 함수(Higher-Order Function)**라는 이름은 **함수를 다루는 추상화 수준**이 더 높다는 데에서 유래했다.
- 보통의 (일반적인) 함수는 **데이터(값)**를 입력으로 받고, 값을 반환한다.
- 이에 반해, 고차 함수는 **함수를 인자로 받거나 함수를 반환한다.**
- 일반 함수는 값을 다루고, 고차 함수는 함수 자체를 다룬다.

즉, `값`을 다루는 것을 넘어, `함수`라는 개념 자체를 값처럼 다룬다는 점에서 **추상화의 수준(계층, order)이 한 단계 높아진다고** 해서 Higher-Order(더 높은 차원의) 함수라고 부른다.

---

## 🤔 문제와 풀이 관련 정리
#### 🔍 용어 - reduce, fold
여러 값을 계산해서 하나의 최종 값을 반환하는 경우 `reduce(축약하다)`, `fold(접는다)` 같은 단어를 사용한다.
- `reduce`: 1, 2, 3, 4라는 숫자를 하나씩 계산하면서 축약하기 때문에 축약하다는 의미의 `reduce`를 사용
- `fold`: 마치 종이를 여러 번 접어서 하나의 작은 뭉치로 만드는 것처럼, 초깃값과 연산을 통해 리스트의 요소를 하나씩 접어서 최종적으로 하나의 값으로 축약한다는 의미이다.

#### 📌 정리
5가지 문제는 자바에서 고차 함수를 구현할 때 자주 등장하는 패턴으로 구성되어 있다.
1. **filter**: 조건(함수)을 인자로 받아, 리스트에서 필요한 요소만 추려내기
2. **map**: 변환 로직(함수)을 인자로 받아, 리스트의 각 요소를 다른 형태로 바꾸기
3. **reduce**: 누적 로직(함수)을 인자로 받아, 리스트의 모든 요소를 하나의 값으로 축약하기
4. **함수를 반환:**: 어떤 문자열/정수 등을 받아서, 그에 맞는 새로운 `함수`를 만들어 돌려주기
5. **함수 합성**: 두 함수를 이어 붙여, 한 번에 변환 로직을 적용할 수 있는 새 함수를 만들기

 
- 위를 이해했다면, filter-map-reduce 등, 컬렉션/스트림 라이브러리에서도 흔히 볼 수 있는 고차 함수 패턴을 깊이 있게 이해할 수 있다.

---
