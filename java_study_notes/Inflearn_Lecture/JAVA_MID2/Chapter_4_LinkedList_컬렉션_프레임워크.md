# 📚 (JAVA 인프런 - 중급 2편) Chapter 4: 컬렉션 프레임워크 - LinkedList
> 📌 공부 날짜: 2025/03/25

---

## ✅ 노드와 연결
- 낭비되는 메모리 없이 딱 필요한 만큼만 메모리를 확보해서 사용하고, 또 앞이나 중간에 데이터를 추가하거나 삭제할 때도 효율적인 자료구조가 있는데, 바로 노드를 만들고 각 노드를 서로 연결하는 방식이다.

> 🔍 정리
> - 노드는 내부에 데이터와 다음 노드에 대한 참조를 가지고 있다.
> - 지금까지 설명한 구조는 각각의 노드가 참조를 통해 연결(`Link`)되어 있다.
> - 데이터를 추가할 때 동적으로 필요한 만큼의 노드만 만들어서 연결하면 된다. 따라서 배열과 다르게 메모리를 낭비하지 않는다.
>   - 물론 `next` 필드를 통해 참조값을 보관해야 하기 때문에 배열과 비교해서 추가적인 메모리 낭비도 발생한다.
> - **이렇게 각각의 노드를 연결(링크)해서 사용하는 자료구조로 리스트를 만들 수 있는데, 이것을 `연결리스트`라 한다.**

---

## ✅ 직접 구현한 연결리스트(링크드 리스트)
> - `리스트 자료구조`: 순서가 있고, 중복을 허용하는 자료구조를 `List`라 한다.

### 🔍 연결리스트와 빅오
1. get(int index)
    - 특정 위치에 있는 데이터를 반환해준다.
    - 특정 위치의 노드를 찾는데 `O(n)`이 걸린다.
> - 배열은 인덱스로 원하는 데이터를 즉시 찾을 수 있다. 따라서 배열리스트는 `O(1)`의 성능이다.
> - 하지만 연결리스트는 배열이 아니라 노드에 대한 참조가 있을 뿐이다. 따라서 인덱스로 원하는 위치의 데이터를 찾으려면 인덱스 숫자만큼 다음 노드를 반복해서 찾아야 한다.
> - 따라서 인덱스 조회 성능이 나쁘다.

2. add(Object e) 
    - 마지막에 데이터를 추가
    - 마지막 노드를 찾는데 `O(n)`이 소요. 마지막에 새로운 노드를 추가하는데 `O(1)`이 걸림.
    - 따라서 `O(n)`이다.

3. set(int index, Object element) 
    - 특정 위치에 있는 데이터를 찾아서 변경한다.
    - 특정 위치를 찾는데 `O(n)`이 걸린다.

4. indexOf(Object o) 
    - 데이터를 검색하고, 검색된 위치를 반환.
    - 모든 노드를 순회하면서 같은 데이터가 있는지 찾는다. `O(n)`

### 🔍 정리: 직접 만든 배열리스트와 연결리스트 성능 표
| 기능        | 배열리스트 | 연결리스트 |
|-----------|-------|-------|
| 인덱스 조회    | O(1)  | O(n)  |
| 검색        | O(n)  | O(n)  |
| 앞에 추가(삭제) | O(n)  | O(1)  |
| 뒤에 추가(삭제) | O(1)  | O(n)  |
| 평균 추가(삭제) | O(n)  | O(n)  |

---

## ✅ 배열리스트 vs 연결리스트 사용
- 데이터를 조회할 일이 많고, 뒷 부분에 데이터를 추가한다면 배열리스트가 보통 더 좋은 성능을 제공한다.
- 앞쪽의 데이터를 추가하거나 삭제할 일이 많다면 연결리스트를 사용하는 것이 보통 더 좋은 성능을 제공한다.

> 🔍 참고 - 단일 연결리스트, 이중 연결리스트
> - 4장에 설명한 내용은 단일 연결리스트이다. 노드를 앞 뒤로 연결하는 이중 연결리스트를 사용하면 성능을 더 개선할 수 있다.
> - 자바가 제공하는 연결리스트는 이중 연결리스트이다. 추가로 자바가 제공하는 연결리스트는 마지막 노드를 참조하는 변수를 가지고 있어서, 뒤에 추가하거나 삭제하는 경우에도 `O(1)`의 성능을 제공한다.
> - 연결리스트에도 제네릭을 도입하여 타입 안정성을 확보한다.

---
