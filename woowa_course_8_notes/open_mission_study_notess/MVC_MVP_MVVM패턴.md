# 📖 지식 정리 (우테코를 하며 학습한 내용)
## 1️⃣ MVC 패턴이란?
`MVC 패턴(Model-View-Controller)`은 사용자 인터페이스를 구현하기 위해 사용되는 디자인 패턴으로, 애플리케이션을 세 가지 주요 구성 요소로 나누어 관리한다.

1. **모델(Model)**: 데이터와 비즈니스 로직을 처리한다. 애플리케이션의 데이터 구조를 정의하고 데이터베이스와의 상호작용 및 비즈니스 규칙을 담당한다.

2. **뷰(View)**: 사용자에게 정보를 표시하는 방법(사용자 인터페이스)을 정의한다. 모델이 가지고 있는 정보를 받아 사용자에게 보여주는 역할을 한다.

3. **컨트롤러(Controller)**: 사용자의 입력을 받아 처리하는 부분으로, 사용자의 입력에 따라 모델과 뷰를 업데이트한다.

### MVC 패턴의 장점
1. **분리된 관심사**: `MVC`는 애플리케이션의 입력 로직, 비즈니스 로직, UI 로직을 서로 분리하여 관리하므로, 유지보수 및 확장성이 향상된다.

2. **재사용성 증가**: 모델이 뷰와 컨트롤러로부터 독립되어 있기 때문에, 모델을 다양한 인터페이스에 재사용할 수 있다.

3. **개발 효율성**: 여러 개발자가 모델, 뷰 컨트롤러 각각을 동시에 개발할 수 있어 개발 시간을 단축할 수 있다.

### MVC 패턴의 단점
1. **복잡성 증가**: 작은 프로젝트나 단순한 애플리케이션에 MVC 패턴을 적용하면 오히려 구조가 불필요하게 복잡해질 수 있다.

2. **성능 이슈**: 모델, 뷰, 컨트롤러 간의 지속적인 데이터 교환은 처리 속도를 저하시킬 수 있다.

3. **뷰와 모델 간의 은밀한 의존성**: 뷰가 모델을 직접 호출하게 되는 경우가 많아, 완벽한 분리가 어려울 수 있다.

---

## 2️⃣ MVP 패턴이란?
`MVP 패턴(Model-View-Presenter)`은 MVC(Model-View-Controller) 패턴의 변형으로, 사용자 인터패이스 관련 소프트웨어 개발에서 널리 사용된다.
MVP 패턴은 특히 프레젠테이션 로직을 뷰에서 완전히 분리하려는 목적으로 설계되었다.
이 패턴은 애플리케이션의 프레젠테이션 로직을 처리하는 세 가지 구성 요소로 나눈다.

1. **모델(Model)**: 데이터와 비즈니스 로직을 담당. 데이터의 상태 변화를 저장하고 관리

2. **뷰(View)**: 사용자에게 보이는 UI 구성 요소. HTML, CSS, JavaScript 등을 사용하여 구현할 수 있으며, 사용자 입력을 받아 프레젠터에 전달

3. **프레젠터(Presenter)**: 뷰와 모델 사이의 인터페이스를 관리. 모든 프레젠테이션 로직을 담당하며, 뷰로부터 입력을 받아 모델을 업데이트하고, 모델의 변경 사항을 뷰에 반영한다.

### MVP 패턴의 장점
1. **테스트 용이성**: 프레젠터는 뷰와 직접적으로 결합되어 있지 않기 때문에, 유닛 테스트가 용이함

2. **분리된 관심사**: UI와 비즈니스 로직이 명확히 분리되어 있어 각 부분의 독립적인 개발과 수정이 용이함

3. **재사용성 증가**: 프레젠터는 뷰의 구체적인 구현에 대해 알 필요가 없기 때문에, 다양한 뷰에 재사용할 수 있다.

### MVP 패턴의 단점
1. **복잡성 증가**: 비교적 단순한 애플리케이션에서 MVP 패턴을 사용하면 과도한 복잡성이 추가될 수 있다.

2. **개발 시간 증가**: 분리된 구성 요소들을 관리하면서 발생하는 추가적인 개발 시간이 필요함

3. **리소스 요구량 증가**: 더 많은 클래스와 인터페이스를 정의해야 하므로, 리소스 요구량이 증가할 수 있다.

### MVC에서 MVP로 Controller가 Presenter로 바뀌면서 어떤 차이가 발생할까?
앞서 **MVC에서의 문제는 Controller에서 View와 Model의 강한 결합이 문제**였다.
비즈니스 로직과 View를 분리하기 위한 문제를 해결하기에는 부족했던 MVC 패턴을 MVP에서는 어떻게 개선시켰는가?

model과 view를 interface로 구현한다. Presenter는 View와 Model 사이에서 중개자 역할을 한다.
함수를 통해 Model에서 데이터를 가져와 View에 전달한다.
이를 통해 View와 model 간의 직접적인 의존성을 방지할 수 있다.
interface를 통해 구현하여 상속받고 구현체를 따로 만들어주어야 하지만 **인터페이스의 존재가 View와 Model이 서로를 직접적으로 참조하지 않아 결합을 낮추게 된다.**

---

## 3️⃣ MVVM 패턴(Model-View-ViewModel)
`MVVM 패턴(Model-View-ViewModel)`은 사용자 인터페이스의 설계를 위한 아키텍처 패턴으로, 특히 데이터 바인딩을 중심으로 하는 현대의 UI 개발 프레임워크에서 널리 사용된다.
MVVM은 주로 WPF, Silverlight, natively in AngularJS, Vue.js, ReactJS (with Redux or Mobx) 및 다른 프로그래밍 환경에서 사용된다.
이 패턴은 복잡한 사용자 인터페이스의 개발을 단순화하고, 테스트와 유지보수를 용이하게 하기 위해 설계되었다.
- `데이터 바인딩(Data Binding)`이란?
  - UI와 데이터 사이의 동기화를 담당하여 ViewModel에서 Model이 변경될 때 이를 감지하여 UI를 자동으로 업데이트한다.


1. **모델(Model)**: 비즈니스 로직과 데이터의 접근 계층을 처리. 데이터 모델은 비즈니스 규칙을 포함할 수 있으며, 데이터 저장소와의 통신을 담당

2. **뷰(View)**: 사용자에게 보여지는 UI 요소. 사용자의 입력을 받고, 사용자에게 정보를 시각적으로 표시

3. **뷰모델(ViewModel)**: 뷰와 모델 사이의 매개체 역할. 뷰모델은 명령(command)와 데이터 바인딩을 통해 뷰의 상태와 동작을 캡슐화한다. 뷰모델은 모델에서 데이터를 래핑하고 뷰가 이해할 수 있는 형태로 가공하여 뷰에 전달

### MVVM 패턴의 장점
1. **강력한 데이터 바인딩**: 데이터 바인딩을 통해 뷰와 뷰모델 간의 동기화가 자동으로 이루어져, 코드의 양을 줄이고 복잡성을 감소

2. **분리된 관심사**: 뷰모델은 뷰로부터 UI 로직을 분리하여, 비즈니스 로직과 프레젠테이션 로직의 독립적인 개발과 테스트가 가능하다.

3. **재사용성과 유지보수성 향상**: 뷰모델은 플랫폼에 독립적이므로, 다양한 뷰 또는 플랫폼 간에 재사용이 가능

### MVVM 패턴의 단점
1. **초기 구현 복잡성**: MVVM의 구현은 초기 학습 곡선이 높고 설정에 시간이 소요된다.

2. **성능 문제**: 대규모 데이터 바인딩이 많은 애플리케이션에서 성능 이슈가 발생할 수 있다.

3. **과도한 추상화**: 때때로 뷰모델과 모델 간에 과도한 추상화 레이어가 필요하게 되어 애플리케이션의 복잡성이 증가할 수 있다.

### MVP와의 차이점은 무엇일까?
바로 포인트인 **view와 viewmodel의 느슨한 결합**이다. MVP의 View와 Presenter 간의 의존성은 높다.
그러나 `Data binding`을 통해 MVVM 패턴은 서로의 의존성을 낮출 수 있게 된다.

---

## ☑️ 고민한 내용
이번 과제에서 적용할 수 있는 구조는 결국 MVC 패턴이라고 판단했다.

특히 콘솔 기반 애플리케이션에서는 `View`의 역할이 입력·출력에 집중되고, `Model`과의 의존성을 분리하여 설계하기 비교적 용이하다.

🤔 과제를 진행하며 가장 고민했던 점은 **`InputView`에 입력 안내문까지 포함해야 하는가**?였다.

일부 구조에서는 `View`가 입력만 받고, 안내문이나 비즈니스 메시지는 `Controller`에서 직접 출력하도록 구현하기도 한다.

하지만 내가 실제로 구현한 흐름은 **`Controller`에서 UI 메시지를 조립하고 → `View`에 전달하여 출력하게 하는 방식**이다.

이 방식은 MVC 패턴 관점에서도 충분히 자연스럽다.

왜냐하면 `Controller`는 흐름을 제어하면서 사용자에게 보여줄 메시지를 구성할 수 있고,
`View`는 오직 "출력"이라는 단일 역할만 수행하기 때문이다.

따라서 이러한 구조를 기준으로 다시 생각해보면,
**`InputView`가 안내문까지 함께 관리하는 것이 오히려 더 명확한 책임 분리라고 판단했다**.
- `Controller`는 비즈니스 로직 호출 및 “사용자에게 전달할 메시지 조립”만 담당
- `View(InputView/OutputView)`는 입력 안내 + 실제 입력 및 출력만 담당
- `Model`은 UI 메시지를 전혀 알지 않고 비즈니스 로직만 유지

이 구조에서 `View`는 UI 표현에만 집중하고,
`Controller`는 메시지를 조립하되 출력 형식 자체는 `View`에 위임한다.

결과적으로 **입력 안내문을 `InputView`에 포함하는 것이 MVC의 책임 분리 측면에서도 더 자연스러운 선택**이라고 판단했다.

---

## 🔖 References
- [MVC 패턴, MVP 패턴, MVVM 패턴 장점 단점, 예시](https://yodastudy.tistory.com/87)
- [한 번의 글로 이해하는 소프트웨어 아키텍터 패턴(MVC,MVP,MVVM)](https://dev-musa.tistory.com/entry/%ED%95%9C-%EB%B2%88%EC%9D%98-%EA%B8%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%ED%8C%A8%ED%84%B4-MVC-MVP-MVVM)
