# 📖 지식 정리 (우테코를 하며 학습한 내용)
## 1️⃣ 생성자 대신 정적 팩토리 메서드를 고려하라
생성자(Constructor)는 객체 지향 프로그래밍에서 클래스의 인스턴스를 초기화하는 메서드이다.

주된 목적은 객체 생성시점에 필요한 초기화 작업을 수행하는 것이다.

**정적 팩토리 메서드**(static factory method)는 생성자의 제한점에 대한 대안을 제공하는 재사용 가능한 소프트웨어 설계의 해결책이다.

정적 팩토리 메서드를 생성자 대신 사용함으로써 객체의 생성을 단순화하고 코드의 가독성을 높이는데 사용할 수 있다.

### 1️⃣-2️⃣ 정적 팩토리 메서드가 생성자보다 좋은 이유
> **1. 이름을 가질 수 있다.**
> - 정적 팩토리 메서드의 경우에는 생성자가 여러 개인 경우에 특히 유리하게 작용한다.

> **2. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.**
> - 이미 생성된 객체를 재사용함으로써 메모리 사용을 줄이고 성능을 향상 시킬 수 있다.
> - 이는 특히 불변 객체(Immutable Objects)를 다룰 때 유용하다.

> **3. 반환 타입의 하위 객체를 반환할 수 있는 능력이 있다.**
> - 정적 팩토리 메서드가 인터페이스나 상위 클래스 타입을 반환 타입으로 사용하면서,
> 실제로는 **이 인터페이스나 클래스의 어떤 하위 타입(subtype)의 인스턴스를 반환할 수 있음을** 의미다.
> - 이 접근 방식은 API의 유연성을 제공해 주고,
> 클라이언트에 필요 이상의 많은 정보를 노출하지 않고 API를 설계할 수 있게 해 주어서 보안 측면으로도 유리하다.

> **4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.**
> - 정적 메서드는 **매개변수의 값이나 타입에 따라 다른 클래스의 인스턴스를 반환**할 수 있다.
> - 또한, 조건적으로 객체를 생성하게 할 수 있으며, 이 방식을 사용하면 다양한 타입의 객체를 생성하는 복잡한 로직을 한 메서드 안에 캡슐화할 수 있다.

> **5. 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.**
> - 정적 팩토리 메서드의 유연성과 확장성을 매우 잘 보여주는 특징이다.
> - 이 특징은 특히 서비스 제공자 프레임워크(Service Provider Framework) 같은 디자인 패턴에서 유용하게 사용된다.
> 
> 서비스 제공자 프레임워크는 세 가지 주요 컴포넌트로 구성된다.
> 1. 서비스 인터페이스
> 2. 서비스 제공자 인터페이스
> 3. 서비스 접근 API
> 
> - 정적 팩토리 메서드는 실행 시간(Runtime)에 클래스가 로드되고 인스턴스가 생성된다.
> - 이 방식은 **메서드를 정의할 때는 해당 클래스가 존재하지 않더라도,**
> **나중에 클래스가 로드되면 해당 클래스의 인스턴스를 반환**할 수 있게 한다.

---

### 1️⃣-3️⃣ 정적 팩토리 메서드 단점
> **1. 상속의 제한**
> - 정적 팩토리 메서드를 사용하는 클래스는 대체로 생성자를 공개하지 않고, 객체 생성을 전적으로 이러한 메서드에 의존하도록 설계된다.
> - 특히 클래스가 private 또는 protected 생성자만 제공하고, 정적 팩토리 메서드로만 인스턴스를 생성할 수 있도록 설계되었을 때, 이 클래스를 상속받는 것이 불가능하다.
> - 또한, 객체 생성을 전적으로 메서드에 의존하게 설계되기 때문에, 이 클래스를 상속받아 새로운 하위 클래스를 만드는 것도 어렵거나 불가능할 수 있다.

> **2. 정적 팩토리 메서드 발견성 문제**
> - 앞서 언급한 이름을 지을 수 있다는 특징과 상반된 단점이다.
> - 이름을 지음으로써 코드의 의미와 명확성을 확실히 챙길 수 있는 반면, **개발자가 해당 정적 팩토리 메소드의 존재를 모른다면 다 의미 없다는 말이다.**

---

### 1️⃣-4️⃣ 정적 팩토리 메서드 명명 방식

> **[Type] from:**
> - 매개 변수 하나를 받아서 해당 타입의 인스턴스를 반환한다.
> - ex) Date.from(Instant)

> **of:**
> - 여러 매개변수를 받아 적합 타입의 인스턴스를 반환한다.
> - ex) List.of(1, 2, 3)

> **valueOf:**
> - 매개변수로 전달된 값으로 해당 타입의 인스턴스를 반환한다.
> - valueOf는 주로 타입 변환에 사용된다.
> - ex) Integer.valueOf(String)

> **getInstance, instance:**
> - 인스턴스를 반환하지만, 같은 인스턴스임이 보장되지 않는다.
> - 매개변수에 따라 다른 인스턴스를 반환할 수 있다.
> - ex) Calendar.getInstance()

> **newInstance, create:**
> - 새로운 인스턴스를 생성한다.
> - getInstance와 달리 항상 새로운 인스턴스를 생성함을 나타낸다.
> - ex) Array.newInstance(Class, int)

> **get[Type]:**
> - 특정 타입의 객체를 반환한다.
> - 이 방식은 주로 다른 클래스나 타입의 객체를 반환할 때 사용된다.
> - ex) Files.getBufferedReader(Path)

> **new[Type]:**
> - newInstance와 유사하지만, 생성되는 객체의 타입을 명시적으로 나타낸다.
> - ex) Files.newBufferedReader(Path)

> **[Type]:**
> - getTyoe, newType의 간결한 버전이다.
> - ex) Collections.list()
 
> **withXxx**
> - 전략 주입(Strategy Injection)
> - 목적이 `전략 지정`에 있는 경우, 위와 같은 전통적인 네이밍 규칙에 해당되지 않는다.
> - `withXxx` 패턴은 (전략, 설정, 옵션, 의존성)을 주입할 때 널리 사용하는 실용적 이름이다.

**📌 정적 팩토리가 가져오는 이점은 많지만, 그렇다고 정적 팩토리 메서드가 항상 생성자보다 낫다고 할 수는 없다.**
상황에 따라 적절한 방법을 선택하는 것이 중요하다.

---

## 🔖 References
- [생성자 대신 정적 팩토리 메서드를 고려하라](https://olrlobt.tistory.com/70)
